{
  "address": "0xB9782069b457C43e358D15AA7d8242585c0FB64F",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "emitter",
          "type": "address"
        }
      ],
      "name": "FailedContractCreation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "emitter",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "revertData",
          "type": "bytes"
        }
      ],
      "name": "FailedContractInitialisation",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "emitter",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "revertData",
          "type": "bytes"
        }
      ],
      "name": "FailedEtherTransfer",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "emitter",
          "type": "address"
        }
      ],
      "name": "InvalidNonceValue",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "emitter",
          "type": "address"
        }
      ],
      "name": "InvalidSalt",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "ContractCreation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "name": "ContractCreation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "Create3ProxyContractCreation",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "initCodeHash",
          "type": "bytes32"
        }
      ],
      "name": "computeCreate2Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "initCodeHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "deployer",
          "type": "address"
        }
      ],
      "name": "computeCreate2Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "deployer",
          "type": "address"
        }
      ],
      "name": "computeCreate3Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "computeCreate3Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "computeCreateAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "deployer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        }
      ],
      "name": "computeCreateAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "deployCreate",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "deployCreate2",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "deployCreate2",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "deployCreate2AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        }
      ],
      "name": "deployCreate2AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "deployCreate2AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        }
      ],
      "name": "deployCreate2AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "deployCreate2Clone",
      "outputs": [
        {
          "internalType": "address",
          "name": "proxy",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "deployCreate2Clone",
      "outputs": [
        {
          "internalType": "address",
          "name": "proxy",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "deployCreate3",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "deployCreate3",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        }
      ],
      "name": "deployCreate3AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        }
      ],
      "name": "deployCreate3AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "deployCreate3AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "deployCreate3AndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        }
      ],
      "name": "deployCreateAndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "constructorAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "initCallAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct RaribleCreateX.Values",
          "name": "values",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "refundAddress",
          "type": "address"
        }
      ],
      "name": "deployCreateAndInit",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "deployCreateClone",
      "outputs": [
        {
          "internalType": "address",
          "name": "proxy",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "findCreate2Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "initCodeHash",
          "type": "bytes32"
        }
      ],
      "name": "findCreate2AddressViaHash",
      "outputs": [
        {
          "internalType": "address",
          "name": "computedAddress",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "deploymentAddress",
          "type": "address"
        }
      ],
      "name": "hasBeenDeployed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "initCode",
          "type": "bytes"
        }
      ],
      "name": "safeCreate2",
      "outputs": [
        {
          "internalType": "address",
          "name": "newContract",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3498b5ecaafc1a9fabc9b92df9c2c95ff8a1be676fc24ce410013ee89d491aa7",
  "receipt": {
    "to": null,
    "from": "0xCfDBcc22887744ab38bC447Eb7fc4A419F24923e",
    "contractAddress": "0xB9782069b457C43e358D15AA7d8242585c0FB64F",
    "transactionIndex": 1,
    "gasUsed": "2022824",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000100000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000080000000000001000000000000200000000000000000000000000000000000200000000000000000000000004000000000000000000001000000000000000000000000000000110000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x8c1a09c5dde0a2e1c32f37b1e7c6b632acff87617e7a6763ae826ac820bb19e3",
    "transactionHash": "0x3498b5ecaafc1a9fabc9b92df9c2c95ff8a1be676fc24ce410013ee89d491aa7",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 72558524,
        "transactionHash": "0x3498b5ecaafc1a9fabc9b92df9c2c95ff8a1be676fc24ce410013ee89d491aa7",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000cfdbcc22887744ab38bc447eb7fc4a419f24923e",
          "0x00000000000000000000000025b9fc2ed95bbaa9c030e57c860545a17694f90d"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000434e87274b493700000000000000000000000000000000000000000000000001bc16d674ec8000000000000000000000000000000000000000000000000088e8e698cc1bdbcb2d7000000000000000000000000000000000000000000000000178c84f4da136c9000000000000000000000000000000000000000000000088e929e753432714647",
        "logIndex": 2,
        "blockHash": "0x8c1a09c5dde0a2e1c32f37b1e7c6b632acff87617e7a6763ae826ac820bb19e3"
      }
    ],
    "blockNumber": 72558524,
    "cumulativeGasUsed": "2043824",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "e4da36191ddef1151e489542d1a960e8",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"}],\"name\":\"FailedContractCreation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"revertData\",\"type\":\"bytes\"}],\"name\":\"FailedContractInitialisation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"revertData\",\"type\":\"bytes\"}],\"name\":\"FailedEtherTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"}],\"name\":\"InvalidNonceValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"}],\"name\":\"InvalidSalt\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"ContractCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"Create3ProxyContractCreation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"computeCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"computeCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"}],\"name\":\"computeCreate3Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"computeCreate3Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"computeCreateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"computeCreateAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"deployCreate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"deployCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"deployCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"deployCreate2AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"}],\"name\":\"deployCreate2AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"deployCreate2AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"}],\"name\":\"deployCreate2AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deployCreate2Clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deployCreate2Clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"deployCreate3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"deployCreate3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"}],\"name\":\"deployCreate3AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"}],\"name\":\"deployCreate3AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"deployCreate3AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"deployCreate3AndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"}],\"name\":\"deployCreateAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"constructorAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initCallAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct RaribleCreateX.Values\",\"name\":\"values\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"refundAddress\",\"type\":\"address\"}],\"name\":\"deployCreateAndInit\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"deployCreateClone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"findCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"findCreate2AddressViaHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"computedAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"name\":\"hasBeenDeployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"safeCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"RARIBLE team\",\"custom:based-on\":\"Implementation by pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/) and Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/), modified by RARIBLE team for specific use cases.\",\"details\":\"To simplify testing of non-public variables and functions, we use the `internal` function visibility specifier `internal` for all variables and functions, even though they could technically be `private` since we do not expect anyone to inherit from the `CreateX` contract.\",\"errors\":{\"FailedContractCreation(address)\":[{\"details\":\"Error that occurs when the contract creation failed.\",\"params\":{\"emitter\":\"The contract that emits the error.\"}}],\"FailedContractInitialisation(address,bytes)\":[{\"details\":\"Error that occurs when the contract initialisation call failed.\",\"params\":{\"emitter\":\"The contract that emits the error.\",\"revertData\":\"The data returned by the failed initialisation call.\"}}],\"FailedEtherTransfer(address,bytes)\":[{\"details\":\"Error that occurs when transferring ether has failed.\",\"params\":{\"emitter\":\"The contract that emits the error.\",\"revertData\":\"The data returned by the failed ether transfer.\"}}],\"InvalidNonceValue(address)\":[{\"details\":\"Error that occurs when the nonce value is invalid.\",\"params\":{\"emitter\":\"The contract that emits the error.\"}}],\"InvalidSalt(address)\":[{\"details\":\"Error that occurs when the salt value is invalid.\",\"params\":{\"emitter\":\"The contract that emits the error.\"}}]},\"events\":{\"ContractCreation(address)\":{\"details\":\"Event that is emitted when a contract is successfully created.\",\"params\":{\"newContract\":\"The address of the new contract.\"}},\"ContractCreation(address,bytes32)\":{\"details\":\"Event that is emitted when a contract is successfully created.\",\"params\":{\"newContract\":\"The address of the new contract.\",\"salt\":\"The 32-byte random value used to create the contract address.\"}},\"Create3ProxyContractCreation(address,bytes32)\":{\"details\":\"Event that is emitted when a `CREATE3` proxy contract is successfully created.\",\"params\":{\"newContract\":\"The address of the new proxy contract.\",\"salt\":\"The 32-byte random value used to create the proxy address.\"}}},\"kind\":\"dev\",\"methods\":{\"computeCreate2Address(bytes32,bytes32)\":{\"details\":\"Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.\",\"params\":{\"initCodeHash\":\"The 32-byte bytecode digest of the contract creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"computeCreate2Address(bytes32,bytes32,address)\":{\"details\":\"Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address. This implementation is based on OpenZeppelin: https://web.archive.org/web/20230921113703/https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/Create2.sol.\",\"params\":{\"deployer\":\"The 20-byte deployer address.\",\"initCodeHash\":\"The 32-byte bytecode digest of the contract creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"computeCreate3Address(bytes32)\":{\"details\":\"Returns the address where a contract will be stored if deployed via this contract using the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will result in a new destination address. This implementation is based on Solady: https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\",\"params\":{\"salt\":\"The 32-byte random value used to create the proxy contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"computeCreate3Address(bytes32,address)\":{\"details\":\"Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will result in a new destination address. This implementation is based on Solady: https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\",\"params\":{\"deployer\":\"The 20-byte deployer address.\",\"salt\":\"The 32-byte random value used to create the proxy contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"computeCreateAddress(address,uint256)\":{\"details\":\"Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf) and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/). For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207. Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification, all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the first contract address created by another contract is calculated with a non-zero nonce.\",\"params\":{\"deployer\":\"The 20-byte deployer address.\",\"nonce\":\"The next 32-byte nonce of the deployer address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"computeCreateAddress(uint256)\":{\"details\":\"Returns the address where a contract will be stored if deployed via this contract using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf) and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/). For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207. Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification, all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the first contract address created by another contract is calculated with a non-zero nonce.\",\"params\":{\"nonce\":\"The next 32-byte nonce of this contract.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"deployCreate(bytes)\":{\"details\":\"Deploys a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"initCode\":\"The creation bytecode.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2(bytes)\":{\"details\":\"Deploys a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode` and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"initCode\":\"The creation bytecode.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2(bytes32,bytes)\":{\"details\":\"Deploys a new contract via calling the `CREATE2` opcode and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"initCode\":\"The creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2AndInit(bytes,bytes,(uint256,uint256))\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2AndInit(bytes,bytes,(uint256,uint256),address)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"refundAddress\":\"The 20-byte address where any excess ether is returned to.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2AndInit(bytes32,bytes,bytes,(uint256,uint256))\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE2` opcode and using the salt value `salt`, creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2AndInit(bytes32,bytes,bytes,(uint256,uint256),address)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE2` opcode and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"refundAddress\":\"The 20-byte address where any excess ether is returned to.\",\"salt\":\"The 32-byte random value used to create the contract address.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate2Clone(address,bytes)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt value `salt`, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed proxy contract.\",\"implementation\":\"The 20-byte implementation contract address.\"},\"returns\":{\"proxy\":\"The 20-byte address where the clone was deployed.\"}},\"deployCreate2Clone(bytes32,address,bytes)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt value `salt`, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed proxy contract.\",\"implementation\":\"The 20-byte implementation contract address.\",\"salt\":\"The 32-byte random value used to create the proxy contract address.\"},\"returns\":{\"proxy\":\"The 20-byte address where the clone was deployed.\"}},\"deployCreate3(bytes)\":{\"details\":\"Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"initCode\":\"The creation bytecode.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate3(bytes32,bytes)\":{\"custom:security\":\"We strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.\",\"details\":\"Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"initCode\":\"The creation bytecode.\",\"salt\":\"The 32-byte random value used to create the proxy contract address.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate3AndInit(bytes,bytes,(uint256,uint256))\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate3AndInit(bytes,bytes,(uint256,uint256),address)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"refundAddress\":\"The 20-byte address where any excess ether is returned to.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate3AndInit(bytes32,bytes,bytes,(uint256,uint256))\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system. Furthermore, we strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.\",\"details\":\"Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"salt\":\"The 32-byte random value used to create the proxy contract address.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreate3AndInit(bytes32,bytes,bytes,(uint256,uint256),address)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system. Furthermore, we strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.\",\"details\":\"Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"refundAddress\":\"The 20-byte address where any excess ether is returned to.\",\"salt\":\"The 32-byte random value used to create the proxy contract address.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreateAndInit(bytes,bytes,(uint256,uint256))\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreateAndInit(bytes,bytes,(uint256,uint256),address)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys and initialises a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed contract.\",\"initCode\":\"The creation bytecode.\",\"refundAddress\":\"The 20-byte address where any excess ether is returned to.\",\"values\":\"The specific `payable` amounts for the deployment and initialisation call.\"},\"returns\":{\"newContract\":\"The 20-byte address where the contract was deployed.\"}},\"deployCreateClone(address,bytes)\":{\"custom:security\":\"This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.\",\"details\":\"Deploys a new EIP-1167 minimal proxy contract using the `CREATE` opcode, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\",\"params\":{\"data\":\"The initialisation code that is passed to the deployed proxy contract.\",\"implementation\":\"The 20-byte implementation contract address.\"},\"returns\":{\"proxy\":\"The 20-byte address where the clone was deployed.\"}},\"findCreate2Address(bytes32,bytes)\":{\"details\":\"Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.\",\"params\":{\"initCode\":\"The 32-byte bytecode digest of the contract creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"findCreate2AddressViaHash(bytes32,bytes32)\":{\"details\":\"Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.\",\"params\":{\"initCodeHash\":\"The 32-byte bytecode digest of the contract creation bytecode.\",\"salt\":\"The 32-byte random value used to create the contract address.\"},\"returns\":{\"computedAddress\":\"The 20-byte address where a contract will be stored.\"}},\"hasBeenDeployed(address)\":{\"details\":\"Determine if a contract has already been deployed by the factory to a given address.\",\"params\":{\"deploymentAddress\":\"address The contract address to check.\"},\"returns\":{\"_0\":\"True if the contract has been deployed, false otherwise.\"}},\"safeCreate2(bytes32,bytes)\":{\"details\":\"Create a contract using CREATE2 by submitting a given salt or nonce along with the initialization code for the contract. Note that the first 20 bytes of the salt must match those of the calling address, which prevents contract creation events from being submitted by unintended parties.\",\"params\":{\"initCode\":\"bytes The initialization code that will be passed into the CREATE2 call.\",\"salt\":\"bytes32 The nonce that will be passed into the CREATE2 call.\"},\"returns\":{\"newContract\":\"Address of the contract that will be created, or the null address if a contract already exists at that address.\"}}},\"stateVariables\":{\"_SELF\":{\"details\":\"Caches the contract address at construction, to be used for the custom errors.\"}},\"title\":\"CreateX Factory Smart Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Factory smart contract to make easier and safer usage of the `CREATE` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f0?fork=shanghai) and `CREATE2` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f5?fork=shanghai) EVM opcodes as well as of `CREATE3`-based (https://web.archive.org/web/20230921103920/https://github.com/ethereum/EIPs/pull/3171) contract creations.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RaribleCreateX.sol\":\"RaribleCreateX\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/RaribleCreateX.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.20;\\n\\n/**\\n * @title CreateX Factory Smart Contract\\n * @author RARIBLE team\\n * @notice Factory smart contract to make easier and safer usage of the\\n * `CREATE` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f0?fork=shanghai) and `CREATE2`\\n * (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f5?fork=shanghai) EVM opcodes as well as of\\n * `CREATE3`-based (https://web.archive.org/web/20230921103920/https://github.com/ethereum/EIPs/pull/3171) contract creations.\\n * @dev To simplify testing of non-public variables and functions, we use the `internal`\\n * function visibility specifier `internal` for all variables and functions, even though\\n * they could technically be `private` since we do not expect anyone to inherit from\\n * the `CreateX` contract.\\n * @custom:based-on Implementation by pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)\\n * and Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/), modified by RARIBLE team\\n * for specific use cases.\\n */\\ncontract RaribleCreateX {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         IMMUTABLES                         */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Caches the contract address at construction, to be used for the custom errors.\\n     */\\n    address internal immutable _SELF = address(this);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CREATE2 MAPPING                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    mapping(address => bool) private _create2Deployed;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      CREATE2 MODIFIER                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\\n     * those of the calling account. This provides protection against the salt\\n     * being stolen by frontrunners or other attackers. The protection can also be\\n     * bypassed if desired by setting each of the first 20 bytes to zero.\\n     * @param salt bytes32 The salt value to check against the calling address.\\n     * */\\n    modifier containsCaller(bytes32 salt) {\\n        // prevent contract submissions from being stolen from tx.pool by requiring\\n        // that the first 20 bytes of the submitted salt match msg.sender.\\n        require(\\n        (address(bytes20(salt)) == msg.sender) ||\\n        (bytes20(salt) == bytes20(0)),\\n        \\\"Invalid salt - first 20 bytes of the salt must match calling address.\\\"\\n        );\\n        _;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                            TYPES                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Struct for the `payable` amounts in a deploy-and-initialise call.\\n     */\\n    struct Values {\\n        uint256 constructorAmount;\\n        uint256 initCallAmount;\\n    }\\n\\n    /**\\n     * @dev Enum for the selection of a permissioned deploy protection.\\n     */\\n    enum SenderBytes {\\n        MsgSender,\\n        ZeroAddress,\\n        Random\\n    }\\n\\n    /**\\n     * @dev Enum for the selection of a cross-chain redeploy protection.\\n     */\\n    enum RedeployProtectionFlag {\\n        True,\\n        False,\\n        Unspecified\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Event that is emitted when a contract is successfully created.\\n     * @param newContract The address of the new contract.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     */\\n    event ContractCreation(address indexed newContract, bytes32 indexed salt);\\n\\n    /**\\n     * @dev Event that is emitted when a contract is successfully created.\\n     * @param newContract The address of the new contract.\\n     */\\n    event ContractCreation(address indexed newContract);\\n\\n    /**\\n     * @dev Event that is emitted when a `CREATE3` proxy contract is successfully created.\\n     * @param newContract The address of the new proxy contract.\\n     * @param salt The 32-byte random value used to create the proxy address.\\n     */\\n    event Create3ProxyContractCreation(address indexed newContract, bytes32 indexed salt);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Error that occurs when the contract creation failed.\\n     * @param emitter The contract that emits the error.\\n     */\\n    error FailedContractCreation(address emitter);\\n\\n    /**\\n     * @dev Error that occurs when the contract initialisation call failed.\\n     * @param emitter The contract that emits the error.\\n     * @param revertData The data returned by the failed initialisation call.\\n     */\\n    error FailedContractInitialisation(address emitter, bytes revertData);\\n\\n    /**\\n     * @dev Error that occurs when the salt value is invalid.\\n     * @param emitter The contract that emits the error.\\n     */\\n    error InvalidSalt(address emitter);\\n\\n    /**\\n     * @dev Error that occurs when the nonce value is invalid.\\n     * @param emitter The contract that emits the error.\\n     */\\n    error InvalidNonceValue(address emitter);\\n\\n    /**\\n     * @dev Error that occurs when transferring ether has failed.\\n     * @param emitter The contract that emits the error.\\n     * @param revertData The data returned by the failed ether transfer.\\n     */\\n    error FailedEtherTransfer(address emitter, bytes revertData);\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           CREATE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Deploys a new contract via calling the `CREATE` opcode and using the creation\\n     * bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs,\\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero,\\n     * `initCode` must have a `payable` constructor.\\n     * @param initCode The creation bytecode.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     */\\n    function deployCreate(bytes memory initCode) public payable returns (address newContract) {\\n        assembly (\\\"memory-safe\\\") {\\n            newContract := create(callvalue(), add(initCode, 0x20), mload(initCode))\\n        }\\n        _requireSuccessfulContractCreation({newContract: newContract});\\n        emit ContractCreation({newContract: newContract});\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to\\n     * save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount`\\n     * is non-zero, `initCode` must have a `payable` constructor.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreateAndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values,\\n        address refundAddress\\n    ) public payable returns (address newContract) {\\n        assembly (\\\"memory-safe\\\") {\\n            newContract := create(mload(values), add(initCode, 0x20), mload(initCode))\\n        }\\n        _requireSuccessfulContractCreation({newContract: newContract});\\n        emit ContractCreation({newContract: newContract});\\n\\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\\n        if (!success) {\\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\\n        }\\n\\n        if (_SELF.balance != 0) {\\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\\n            // opcode) will be part of the refund transaction.\\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\\\"\\\");\\n            if (!success) {\\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\\n     * amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not\\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreateAndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values\\n    ) public payable returns (address newContract) {\\n        newContract = deployCreateAndInit({initCode: initCode, data: data, values: values, refundAddress: msg.sender});\\n    }\\n\\n    /**\\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE` opcode, and initialises\\n     * the implementation contract using the implementation address `implementation`, the initialisation\\n     * code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser\\n     * function called via `data` must be `payable`.\\n     * @param implementation The 20-byte implementation contract address.\\n     * @param data The initialisation code that is passed to the deployed proxy contract.\\n     * @return proxy The 20-byte address where the clone was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreateClone(address implementation, bytes memory data) public payable returns (address proxy) {\\n        bytes20 implementationInBytes = bytes20(implementation);\\n        assembly (\\\"memory-safe\\\") {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                hex\\\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\\\"\\n            )\\n            mstore(add(clone, 0x14), implementationInBytes)\\n            mstore(\\n                add(clone, 0x28),\\n                hex\\\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\\\"\\n            )\\n            proxy := create(0, clone, 0x37)\\n        }\\n        if (proxy == address(0)) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n        emit ContractCreation({newContract: proxy});\\n\\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\\n        _requireSuccessfulContractInitialisation({\\n            success: success,\\n            returnData: returnData,\\n            implementation: implementation\\n        });\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\\n     * the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding\\n     * scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\\n     *\\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\\n     * first contract address created by another contract is calculated with a non-zero nonce.\\n     * @param deployer The 20-byte deployer address.\\n     * @param nonce The next 32-byte nonce of the deployer address.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreateAddress(address deployer, uint256 nonce) public view returns (address computedAddress) {\\n        bytes memory data;\\n        bytes1 len = bytes1(0x94);\\n\\n        // The theoretical allowed limit, based on EIP-2681, for an account nonce is 2**64-2:\\n        // https://web.archive.org/web/20230921113252/https://eips.ethereum.org/EIPS/eip-2681.\\n        if (nonce > type(uint64).max - 1) {\\n            revert InvalidNonceValue({emitter: _SELF});\\n        }\\n\\n        // The integer zero is treated as an empty byte string and therefore has only one length prefix,\\n        // 0x80, which is calculated via 0x80 + 0.\\n        if (nonce == 0x00) {\\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, bytes1(0x80));\\n        }\\n        // A one-byte integer in the [0x00, 0x7f] range uses its own value as a length prefix, there is no\\n        // additional \\\"0x80 + length\\\" prefix that precedes it.\\n        else if (nonce <= 0x7f) {\\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, uint8(nonce));\\n        }\\n        // In the case of `nonce > 0x7f` and `nonce <= type(uint8).max`, we have the following encoding scheme\\n        // (the same calculation can be carried over for higher nonce bytes):\\n        // 0xda = 0xc0 (short RLP prefix) + 0x1a (= the bytes length of: 0x94 + address + 0x84 + nonce, in hex),\\n        // 0x94 = 0x80 + 0x14 (= the bytes length of an address, 20 bytes, in hex),\\n        // 0x84 = 0x80 + 0x04 (= the bytes length of the nonce, 4 bytes, in hex).\\n        else if (nonce <= type(uint8).max) {\\n            data = abi.encodePacked(bytes1(0xd7), len, deployer, bytes1(0x81), uint8(nonce));\\n        } else if (nonce <= type(uint16).max) {\\n            data = abi.encodePacked(bytes1(0xd8), len, deployer, bytes1(0x82), uint16(nonce));\\n        } else if (nonce <= type(uint24).max) {\\n            data = abi.encodePacked(bytes1(0xd9), len, deployer, bytes1(0x83), uint24(nonce));\\n        } else if (nonce <= type(uint32).max) {\\n            data = abi.encodePacked(bytes1(0xda), len, deployer, bytes1(0x84), uint32(nonce));\\n        } else if (nonce <= type(uint40).max) {\\n            data = abi.encodePacked(bytes1(0xdb), len, deployer, bytes1(0x85), uint40(nonce));\\n        } else if (nonce <= type(uint48).max) {\\n            data = abi.encodePacked(bytes1(0xdc), len, deployer, bytes1(0x86), uint48(nonce));\\n        } else if (nonce <= type(uint56).max) {\\n            data = abi.encodePacked(bytes1(0xdd), len, deployer, bytes1(0x87), uint56(nonce));\\n        } else {\\n            data = abi.encodePacked(bytes1(0xde), len, deployer, bytes1(0x88), uint64(nonce));\\n        }\\n\\n        computedAddress = address(uint160(uint256(keccak256(data))));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via this contract\\n     * using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP)\\n     * encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\\n     *\\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\\n     * first contract address created by another contract is calculated with a non-zero nonce.\\n     * @param nonce The next 32-byte nonce of this contract.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreateAddress(uint256 nonce) public view returns (address computedAddress) {\\n        computedAddress = computeCreateAddress({deployer: _SELF, nonce: nonce});\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           CREATE2                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the salt value `salt`,\\n     * the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs,\\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode`\\n     * must have a `payable` constructor.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCode The creation bytecode.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     */\\n    function deployCreate2(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\\n        bytes32 guardedSalt = _guard({salt: salt});\\n        assembly (\\\"memory-safe\\\") {\\n            newContract := create2(callvalue(), add(initCode, 0x20), mload(initCode), guardedSalt)\\n        }\\n        _requireSuccessfulContractCreation({newContract: newContract});\\n\\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\\n        _create2Deployed[newContract] = true;\\n\\n\\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\\n    }\\n\\n    /**\\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the creation bytecode\\n     * `initCode` and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\\n     * diverse selection of block and transaction properties. This approach does not guarantee true\\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\\n     * @param initCode The creation bytecode.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     */\\n    function deployCreate2(bytes memory initCode) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate2`.\\n        newContract = deployCreate2({salt: _generateSalt(), initCode: initCode});\\n    }\\n\\n    /**\\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\\n     * along with the initialization code for the contract. Note that the first 20\\n     * bytes of the salt must match those of the calling address, which prevents\\n     * contract creation events from being submitted by unintended parties.\\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\\n     * @param initCode bytes The initialization code that will be passed\\n     * into the CREATE2 call.\\n     * @return newContract Address of the contract that will be created, or the null address\\n     * if a contract already exists at that address.\\n     */\\n    function safeCreate2(bytes32 salt, bytes memory initCode) public payable containsCaller(salt) returns (address newContract) {\\n        newContract = deployCreate2({salt: salt, initCode: initCode});\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\\n     * salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct\\n     * for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs.\\n     * In order to save deployment costs, we do not sanity check the `initCode` length. Note that if\\n     * `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2AndInit(\\n        bytes32 salt,\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values,\\n        address refundAddress\\n    ) public payable returns (address newContract) {\\n        bytes32 guardedSalt = _guard({salt: salt});\\n        assembly (\\\"memory-safe\\\") {\\n            newContract := create2(mload(values), add(initCode, 0x20), mload(initCode), guardedSalt)\\n        }\\n        _requireSuccessfulContractCreation({newContract: newContract});\\n\\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\\n        _create2Deployed[newContract] = true;\\n\\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\\n\\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\\n        if (!success) {\\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\\n        }\\n\\n        if (_SELF.balance != 0) {\\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\\n            // opcode) will be part of the refund transaction.\\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\\\"\\\");\\n            if (!success) {\\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\\n     * salt value `salt`, creation bytecode `initCode`, the initialisation code `data`, the struct for\\n     * the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs,\\n     * we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2AndInit(\\n        bytes32 salt,\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate2AndInit`.\\n        newContract = deployCreate2AndInit({\\n            salt: salt,\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: msg.sender\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value\\n     * is calculated pseudo-randomly using a diverse selection of block and transaction properties.\\n     * This approach does not guarantee true randomness! In order to save deployment costs, we do not\\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode`\\n     * must have a `payable` constructor.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2AndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values,\\n        address refundAddress\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate2AndInit`.\\n        newContract = deployCreate2AndInit({\\n            salt: _generateSalt(),\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: refundAddress\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts\\n     * `values`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\\n     * diverse selection of block and transaction properties. This approach does not guarantee true\\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\\n     * Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\\n     * and any excess ether is returned to `msg.sender`.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2AndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate2AndInit`.\\n        newContract = deployCreate2AndInit({\\n            salt: _generateSalt(),\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: msg.sender\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\\n     * value `salt`, and initialises the implementation contract using the implementation address\\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if\\n     * `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @param implementation The 20-byte implementation contract address.\\n     * @param data The initialisation code that is passed to the deployed proxy contract.\\n     * @return proxy The 20-byte address where the clone was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2Clone(\\n        bytes32 salt,\\n        address implementation,\\n        bytes memory data\\n    ) public payable returns (address proxy) {\\n        bytes32 guardedSalt = _guard({salt: salt});\\n        bytes20 implementationInBytes = bytes20(implementation);\\n        assembly (\\\"memory-safe\\\") {\\n            let clone := mload(0x40)\\n            mstore(\\n                clone,\\n                hex\\\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\\\"\\n            )\\n            mstore(add(clone, 0x14), implementationInBytes)\\n            mstore(\\n                add(clone, 0x28),\\n                hex\\\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\\\"\\n            )\\n            proxy := create2(0, clone, 0x37, guardedSalt)\\n        }\\n        if (proxy == address(0)) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n        emit ContractCreation({newContract: proxy, salt: guardedSalt});\\n\\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\\n        _requireSuccessfulContractInitialisation({\\n            success: success,\\n            returnData: returnData,\\n            implementation: implementation\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\\n     * value `salt`, and initialises the implementation contract using the implementation address\\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. The salt value is\\n     * calculated pseudo-randomly using a diverse selection of block and transaction properties. This\\n     * approach does not guarantee true randomness! Note that if `msg.value` is non-zero, the initialiser\\n     * function called via `data` must be `payable`.\\n     * @param implementation The 20-byte implementation contract address.\\n     * @param data The initialisation code that is passed to the deployed proxy contract.\\n     * @return proxy The 20-byte address where the clone was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate2Clone(address implementation, bytes memory data) public payable returns (address proxy) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate2Clone`.\\n        proxy = deployCreate2Clone({salt: _generateSalt(), implementation: implementation, data: data});\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\\n     * destination address.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) public view returns (address computedAddress) {\\n        computedAddress = computeCreate2Address({salt: salt, initCodeHash: initCodeHash, deployer: _SELF});\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\\n     * destination address. This implementation is based on OpenZeppelin:\\n     * https://web.archive.org/web/20230921113703/https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/Create2.sol.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\\n     * @param deployer The 20-byte deployer address.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreate2Address(\\n        bytes32 salt,\\n        bytes32 initCodeHash,\\n        address deployer\\n    ) public pure returns (address computedAddress) {\\n        assembly (\\\"memory-safe\\\") {\\n            // |                      | \\u2193 ptr ...  \\u2193 ptr + 0x0B (start) ...  \\u2193 ptr + 0x20 ...  \\u2193 ptr + 0x40 ...   |\\n            // |----------------------|---------------------------------------------------------------------------|\\n            // | initCodeHash         |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt                 |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer             | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF                 |            FF                                                             |\\n            // |----------------------|---------------------------------------------------------------------------|\\n            // | memory               | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak256(start, 85) |            \\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191\\u2191 |\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x40), initCodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer)\\n            let start := add(ptr, 0x0b)\\n            mstore8(start, 0xff)\\n            computedAddress := keccak256(start, 85)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\\n     * destination address.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function findCreate2AddressViaHash(bytes32 salt, bytes32 initCodeHash) public view returns (address computedAddress) {\\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: initCodeHash, deployer: _SELF});\\n        // return null address to signify failure if contract has been deployed.\\n        if (_create2Deployed[computedAddress]) return address(0);\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\\n     * destination address.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @param initCode The 32-byte bytecode digest of the contract creation bytecode.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function findCreate2Address(bytes32 salt, bytes memory initCode) public view returns (address computedAddress) {\\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: keccak256(abi.encodePacked(initCode)), deployer: _SELF});\\n        // return null address to signify failure if contract has been deployed.\\n        if (_create2Deployed[computedAddress]) return address(0);\\n    }\\n\\n    /**\\n     * @dev Determine if a contract has already been deployed by the factory to a\\n     * given address.\\n     * @param deploymentAddress address The contract address to check.\\n     * @return True if the contract has been deployed, false otherwise.\\n     */\\n    function hasBeenDeployed(address deploymentAddress) external view returns (bool) {\\n        // determine if a contract has been deployed to the provided address.\\n        return _create2Deployed[deploymentAddress];\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           CREATE3                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\\n     * as inputs. In order to save deployment costs, we do not sanity check the `initCode` length.\\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This\\n     * implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @param initCode The creation bytecode.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security We strongly recommend implementing a permissioned deploy protection by setting\\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\\n     * proxy deployments on other chains.\\n     */\\n    function deployCreate3(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\\n        bytes32 guardedSalt = _guard({salt: salt});\\n        bytes memory proxyChildBytecode = hex\\\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\\\";\\n        address proxy;\\n        assembly (\\\"memory-safe\\\") {\\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\\n        }\\n        if (proxy == address(0)) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\\n\\n        newContract = computeCreate3Address({salt: guardedSalt});\\n        (bool success, ) = proxy.call{value: msg.value}(initCode);\\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\\n        emit ContractCreation({newContract: newContract});\\n    }\\n\\n    /**\\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block\\n     * and transaction properties. This approach does not guarantee true randomness! In order to save\\n     * deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is\\n     * non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param initCode The creation bytecode.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     */\\n    function deployCreate3(bytes memory initCode) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate3`.\\n        newContract = deployCreate3({salt: _generateSalt(), initCode: initCode});\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\\n     * initialisation code `data`, the struct for the `payable` amounts `values`, the refund address\\n     * `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity\\n     * check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must\\n     * have a `payable` constructor. This implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\\n     * proxy deployments on other chains.\\n     */\\n    function deployCreate3AndInit(\\n        bytes32 salt,\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values,\\n        address refundAddress\\n    ) public payable returns (address newContract) {\\n        bytes32 guardedSalt = _guard({salt: salt});\\n        bytes memory proxyChildBytecode = hex\\\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\\\";\\n        address proxy;\\n        assembly (\\\"memory-safe\\\") {\\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\\n        }\\n        if (proxy == address(0)) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\\n\\n        newContract = computeCreate3Address({salt: guardedSalt});\\n        (bool success, ) = proxy.call{value: values.constructorAmount}(initCode);\\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\\n        emit ContractCreation({newContract: newContract});\\n\\n        bytes memory returnData;\\n        (success, returnData) = newContract.call{value: values.initCallAmount}(data);\\n        if (!success) {\\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\\n        }\\n\\n        if (_SELF.balance != 0) {\\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\\n            // opcode) will be part of the refund transaction.\\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\\\"\\\");\\n            if (!success) {\\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\\n     * initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as\\n     * inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note\\n     * that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\\n     * proxy deployments on other chains.\\n     */\\n    function deployCreate3AndInit(\\n        bytes32 salt,\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate3AndInit`.\\n        newContract = deployCreate3AndInit({\\n            salt: salt,\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: msg.sender\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\\n     * the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value`\\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and\\n     * transaction properties. This approach does not guarantee true randomness! In order to save deployment\\n     * costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\\n     * `initCode` must have a `payable` constructor. This implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate3AndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values,\\n        address refundAddress\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate3AndInit`.\\n        newContract = deployCreate3AndInit({\\n            salt: _generateSalt(),\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: refundAddress\\n        });\\n    }\\n\\n    /**\\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\\n     * the struct for the `payable` amounts `values`, `msg.value` as inputs. The salt value is calculated\\n     * pseudo-randomly using a diverse selection of block and transaction properties. This approach does\\n     * not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode`\\n     * length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\\n     * @param initCode The creation bytecode.\\n     * @param data The initialisation code that is passed to the deployed contract.\\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\\n     * @return newContract The 20-byte address where the contract was deployed.\\n     * @custom:security This function allows for reentrancy, however we refrain from adding\\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\\n     */\\n    function deployCreate3AndInit(\\n        bytes memory initCode,\\n        bytes memory data,\\n        Values memory values\\n    ) public payable returns (address newContract) {\\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\\n        // `deployCreate3AndInit`.\\n        newContract = deployCreate3AndInit({\\n            salt: _generateSalt(),\\n            initCode: initCode,\\n            data: data,\\n            values: values,\\n            refundAddress: msg.sender\\n        });\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\\n     * result in a new destination address. This implementation is based on Solady:\\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @param deployer The 20-byte deployer address.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreate3Address(bytes32 salt, address deployer) public pure returns (address computedAddress) {\\n        assembly (\\\"memory-safe\\\") {\\n            let ptr := mload(0x40)\\n            mstore(0x00, deployer)\\n            mstore8(0x0b, 0xff)\\n            mstore(0x20, salt)\\n            mstore(\\n                0x40,\\n                hex\\\"21_c3_5d_be_1b_34_4a_24_88_cf_33_21_d6_ce_54_2f_8e_9f_30_55_44_ff_09_e4_99_3a_62_31_9a_49_7c_1f\\\"\\n            )\\n            mstore(0x14, keccak256(0x0b, 0x55))\\n            mstore(0x40, ptr)\\n            mstore(0x00, 0xd694)\\n            mstore8(0x34, 0x01)\\n            computedAddress := keccak256(0x1e, 0x17)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\\n     * result in a new destination address. This implementation is based on Solady:\\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\\n     * @param salt The 32-byte random value used to create the proxy contract address.\\n     * @return computedAddress The 20-byte address where a contract will be stored.\\n     */\\n    function computeCreate3Address(bytes32 salt) public view returns (address computedAddress) {\\n        computedAddress = computeCreate3Address({salt: salt, deployer: _SELF});\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                      HELPER FUNCTIONS                      */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /**\\n     * @dev Implements different safeguarding mechanisms depending on the encoded values in the salt\\n     * (`||` stands for byte-wise concatenation):\\n     *   => salt (32 bytes) = 0xbebebebebebebebebebebebebebebebebebebebe||ff||1212121212121212121212\\n     *   - The first 20 bytes (i.e. `bebebebebebebebebebebebebebebebebebebebe`) may be used to\\n     *     implement a permissioned deploy protection by setting them equal to `msg.sender`,\\n     *   - The 21st byte (i.e. `ff`) may be used to implement a cross-chain redeploy protection by\\n     *     setting it equal to `0x01`,\\n     *   - The last random 11 bytes (i.e. `1212121212121212121212`) allow for 2**88 bits of entropy\\n     *     for mining a salt.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @return guardedSalt The guarded 32-byte random value used to create the contract address.\\n     */\\n    function _guard(bytes32 salt) internal view returns (bytes32 guardedSalt) {\\n        (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) = _parseSalt({salt: salt});\\n\\n        if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.True) {\\n            // Configures a permissioned deploy protection as well as a cross-chain redeploy protection.\\n            guardedSalt = keccak256(abi.encode(msg.sender, block.chainid, salt));\\n        } else if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.False) {\\n            // Configures solely a permissioned deploy protection.\\n            guardedSalt = _efficientHash({a: bytes32(uint256(uint160(msg.sender))), b: salt});\\n        } else if (senderBytes == SenderBytes.MsgSender) {\\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\\n            revert InvalidSalt({emitter: _SELF});\\n        } else if (senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.True) {\\n            // Configures solely a cross-chain redeploy protection. In order to prevent a pseudo-randomly\\n            // generated cross-chain redeploy protection, we enforce the zero address check for the first 20 bytes.\\n            guardedSalt = _efficientHash({a: bytes32(block.chainid), b: salt});\\n        } else if (\\n            senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.Unspecified\\n        ) {\\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\\n            revert InvalidSalt({emitter: _SELF});\\n        } else {\\n            // For the non-pseudo-random cases, the salt value `salt` is hashed to prevent the safeguard mechanisms\\n            // from being bypassed. Otherwise, the salt value `salt` is not modified.\\n            guardedSalt = (salt != _generateSalt()) ? keccak256(abi.encode(salt)) : salt;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the enum for the selection of a permissioned deploy protection as well as a\\n     * cross-chain redeploy protection.\\n     * @param salt The 32-byte random value used to create the contract address.\\n     * @return senderBytes The 8-byte enum for the selection of a permissioned deploy protection.\\n     * @return redeployProtectionFlag The 8-byte enum for the selection of a cross-chain redeploy\\n     * protection.\\n     */\\n    function _parseSalt(\\n        bytes32 salt\\n    ) internal view returns (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) {\\n        if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\\\"01\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.True);\\n        } else if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\\\"00\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.False);\\n        } else if (address(bytes20(salt)) == msg.sender) {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.Unspecified);\\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\\\"01\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.True);\\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\\\"00\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.False);\\n        } else if (address(bytes20(salt)) == address(0)) {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.Unspecified);\\n        } else if (bytes1(salt[20]) == hex\\\"01\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.True);\\n        } else if (bytes1(salt[20]) == hex\\\"00\\\") {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.False);\\n        } else {\\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.Unspecified);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the `keccak256` hash of `a` and `b` after concatenation.\\n     * @param a The first 32-byte value to be concatenated and hashed.\\n     * @param b The second 32-byte value to be concatenated and hashed.\\n     * @return hash The 32-byte `keccak256` hash of `a` and `b`.\\n     */\\n    function _efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            hash := keccak256(0x00, 0x40)\\n        }\\n    }\\n\\n    /**\\n     * @dev Generates pseudo-randomly a salt value using a diverse selection of block and\\n     * transaction properties.\\n     * @return salt The 32-byte pseudo-random salt value.\\n     */\\n    function _generateSalt() internal view returns (bytes32 salt) {\\n        unchecked {\\n            salt = keccak256(\\n                abi.encode(\\n                    // We don't use `block.number - 256` (the maximum value on the EVM) to accommodate\\n                    // any chains that may try to reduce the amount of available historical block hashes.\\n                    // We also don't subtract 1 to mitigate any risks arising from consecutive block\\n                    // producers on a PoS chain. Therefore, we use `block.number - 32` as a reasonable\\n                    // compromise, one we expect should work on most chains, which is 1 epoch on Ethereum\\n                    // mainnet. Please note that if you use this function between the genesis block and block\\n                    // number 31, the block property `blockhash` will return zero, but the returned salt value\\n                    // `salt` will still have a non-zero value due to the hashing characteristic and the other\\n                    // remaining properties.\\n                    blockhash(block.number - 32),\\n                    block.coinbase,\\n                    block.number,\\n                    block.timestamp,\\n                    block.prevrandao,\\n                    block.chainid,\\n                    msg.sender\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Ensures that `newContract` is a non-zero byte contract.\\n     * @param success The Boolean success condition.\\n     * @param newContract The 20-byte address where the contract was deployed.\\n     */\\n    function _requireSuccessfulContractCreation(bool success, address newContract) internal view {\\n        // Note that reverting if `newContract == address(0)` isn't strictly necessary here, as if\\n        // the deployment fails, `success == false` should already hold. However, since the `CreateX`\\n        // contract should be usable and safe on a wide range of chains, this check is cheap enough\\n        // that there is no harm in including it (security > gas optimisations). It can potentially\\n        // protect against unexpected chain behaviour or a hypothetical compiler bug that doesn't surface\\n        // the call success status properly.\\n        if (!success || newContract == address(0) || newContract.code.length == 0) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n    }\\n\\n    /**\\n     * @dev Ensures that `newContract` is a non-zero byte contract.\\n     * @param newContract The 20-byte address where the contract was deployed.\\n     */\\n    function _requireSuccessfulContractCreation(address newContract) internal view {\\n        if (newContract == address(0) || newContract.code.length == 0) {\\n            revert FailedContractCreation({emitter: _SELF});\\n        }\\n    }\\n\\n    /**\\n     * @dev Ensures that the contract initialisation call to `implementation` has been successful.\\n     * @param success The Boolean success condition.\\n     * @param returnData The return data from the contract initialisation call.\\n     * @param implementation The 20-byte address where the implementation was deployed.\\n     */\\n    function _requireSuccessfulContractInitialisation(\\n        bool success,\\n        bytes memory returnData,\\n        address implementation\\n    ) internal view {\\n        if (!success || implementation.code.length == 0) {\\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\\n        }\\n    }\\n}\",\"keccak256\":\"0xe64c9265044a64a1728327b1cd3a378e21347ac43400dae14921a6dab3b8bd3c\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523060805234801561001457600080fd5b506080516123bf6100f4600039600081816104fc015281816106550152818161073801528181610892015281816108f801528181610d4e01528181610da801528181610e7201528181610eb701528181610ee901528181610f64015281816110170152818161112d015281816111ac01528181611292015281816112d7015281816113090152818161138401528181611479015281816115e60152818161162b0152818161165d015281816116d8015281816117ce0152818161199901528181611a5f01528181611b0701528181611bad0152611c3001526123bf6000f3fe6080604052600436106101b65760003560e01c806381503da1116100ec578063c3fe107b1161008a578063e437252a11610064578063e437252a1461043e578063e96deee414610451578063f5745aba14610464578063f96644981461047757600080fd5b8063c3fe107b146103f8578063d323826a1461040b578063ddda0acb1461042b57600080fd5b806398e81077116100c657806398e810771461039f5780639c36a286146103b2578063a49a7c90146103c5578063a7db93f2146103e557600080fd5b806381503da11461034c57806385cf97ab1461035f578063890c283b1461037f57600080fd5b80632f990e3f1161015957806364e030871161013357806364e03087146102e65780636cec2536146102f957806374637a7a146103195780637f5653601461033957600080fd5b80632f990e3f146102a057806331a7c8c8146102b357806342d654fc146102c657600080fd5b806326a32fc71161019557806326a32fc71461024757806327fe18221461025a5780632852527a1461026d57806328ddd0461461028057600080fd5b8062d84acb146101bb57806308508b8f146101eb5780632630766814610234575b600080fd5b6101ce6101c9366004611ea6565b61048a565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156101f757600080fd5b50610224610206366004611f40565b6001600160a01b031660009081526020819052604090205460ff1690565b60405190151581526020016101e2565b6101ce610242366004611f5b565b6104a2565b6101ce610255366004611fa1565b610580565b6101ce610268366004611fa1565b610599565b6101ce61027b366004611fd5565b6105d5565b34801561028c57600080fd5b506101ce61029b36600461202b565b610731565b6101ce6102ae366004612044565b61075d565b6101ce6102c1366004612044565b61077b565b3480156102d257600080fd5b506101ce6102e13660046120b8565b610789565b6101ce6102f4366004611f5b565b6107e3565b34801561030557600080fd5b506101ce61031436600461202b565b61088a565b34801561032557600080fd5b506101ce6103343660046120e4565b6108b6565b6101ce610347366004611fa1565b610ce9565b6101ce61035a36600461210e565b610cfc565b34801561036b57600080fd5b506101ce61037a366004611f5b565b610d17565b34801561038b57600080fd5b506101ce61039a366004612145565b610d9f565b6101ce6103ad366004612167565b610dcc565b6101ce6103c0366004611f5b565b610fa9565b3480156103d157600080fd5b506101ce6103e0366004612145565b61111c565b6101ce6103f33660046121e1565b611151565b6101ce610406366004612044565b6113cb565b34801561041757600080fd5b506101ce610426366004612270565b6113e1565b6101ce6104393660046121e1565b61140b565b6101ce61044c366004612167565b611721565b6101ce61045f366004611ea6565b611737565b6101ce610472366004612167565b611746565b6101ce61048536600461210e565b61175c565b6000610499858585853361140b565b95945050505050565b6000806104ae84611894565b90508083516020850134f591506104c482611acd565b6001600160a01b03821660009081526020819052604090205460ff161561052e5760405163602e773d60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660048201526024015b60405180910390fd5b6001600160a01b038216600081815260208190526040808220805460ff19166001179055518392917fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f791a35092915050565b600061059361058d611b37565b836104a2565b92915050565b600081516020830134f090506105ae81611acd565b6040516001600160a01b0382169060008051602061236a83398151915290600090a2919050565b6000806105e185611894565b905060008460601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b6028820152826037826000f59350506001600160a01b0383166106825760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405182906001600160a01b038516907fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f790600090a3600080846001600160a01b031634876040516106d491906122c0565b60006040518083038185875af1925050503d8060008114610711576040519150601f19603f3d011682016040523d82523d6000602084013e610716565b606091505b5091509150610726828289611b91565b505050509392505050565b60006105937f0000000000000000000000000000000000000000000000000000000000000000836108b6565b600061077361076a611b37565b8585853361140b565b949350505050565b600061077384848433610dcc565b60006040518260005260ff600b53836020527f21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f6040526055600b20601452806040525061d694600052600160345350506017601e20919050565b600082606081901c33148061080057506001600160601b03198116155b6108805760405162461bcd60e51b815260206004820152604560248201527f496e76616c69642073616c74202d206669727374203230206279746573206f6660448201527f207468652073616c74206d757374206d617463682063616c6c696e67206164646064820152643932b9b99760d91b608482015260a401610525565b61077384846104a2565b6000610593827f0000000000000000000000000000000000000000000000000000000000000000610789565b60006060602560fa1b6108d160016001600160401b036122dc565b6001600160401b031684111561092557604051633c55ab3b60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b8360000361098257604051606b60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152600160ff1b60368201526037015b6040516020818303038152906040529150610cd9565b607f84116109cf57604051606b60f91b60208201526001600160f81b031980831660218301526001600160601b0319606088901b16602283015260f886901b16603682015260370161096c565b60ff8411610a265760405160d760f81b60208201526001600160f81b031980831660218301526001600160601b0319606088901b166022830152608160f81b603683015260f886901b16603782015260380161096c565b61ffff8411610a8657604051601b60fb1b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152604160f91b60368201526001600160f01b031960f086901b16603782015260390161096c565b62ffffff8411610ae75760405160d960f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608360f81b60368201526001600160e81b031960e886901b166037820152603a0161096c565b63ffffffff8411610b4957604051606d60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152602160fa1b60368201526001600160e01b031960e086901b166037820152603b0161096c565b64ffffffffff8411610bac5760405160db60f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608560f81b60368201526001600160d81b031960d886901b166037820152603c0161096c565b65ffffffffffff8411610c1057604051603760fa1b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152604360f91b60368201526001600160d01b031960d086901b166037820152603d0161096c565b66ffffffffffffff8411610c755760405160dd60f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608760f81b60368201526001600160c81b031960c886901b166037820152603e0161096c565b604051606f60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152601160fb1b60368201526001600160c01b031960c086901b166037820152603f0160405160208183030381529060405291505b5080516020909101209392505050565b6000610593610cf6611b37565b83610fa9565b6000610d10610d09611b37565b84846105d5565b9392505050565b6000610d72610d2584611894565b83604051602001610d3691906122c0565b604051602081830303815290604052805190602001207f00000000000000000000000000000000000000000000000000000000000000006113e1565b6001600160a01b03811660009081526020819052604090205490915060ff16156105935750600092915050565b6000610d1083837f00000000000000000000000000000000000000000000000000000000000000006113e1565b60008451602086018451f09050610de281611acd565b6040516001600160a01b0382169060008051602061236a83398151915290600090a2600080826001600160a01b0316856020015187604051610e2491906122c0565b60006040518083038185875af1925050503d8060008114610e61576040519150601f19603f3d011682016040523d82523d6000602084013e610e66565b606091505b509150915081610ead577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163115610f9f57836001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d8060008114610f52576040519150601f19603f3d011682016040523d82523d6000602084013e610f57565b606091505b50909250905081610f9f577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b5050949350505050565b600080610fb584611894565b905060006040518060400160405280601081526020016f67363d3d37363d34f03d5260086018f360801b81525090506000828251602084016000f590506001600160a01b0381166110445760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405183906001600160a01b038316907f2feea65dd4e9f9cbd86b74b7734210c59a1b2981b5b137bd0ee3e208200c906790600090a36110838361088a565b93506000816001600160a01b031634876040516110a091906122c0565b60006040518083038185875af1925050503d80600081146110dd576040519150601f19603f3d011682016040523d82523d6000602084013e6110e2565b606091505b505090506110f08186611bed565b6040516001600160a01b0386169060008051602061236a83398151915290600090a25050505092915050565b6000610d7261112a84611894565b837f00000000000000000000000000000000000000000000000000000000000000006113e1565b60008061115d87611894565b9050808651602088018651f5915061117482611acd565b6001600160a01b03821660009081526020819052604090205460ff16156111d95760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b6001600160a01b038216600081815260208190526040808220805460ff19166001179055518392917fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f791a3600080836001600160a01b031686602001518860405161124491906122c0565b60006040518083038185875af1925050503d8060008114611281576040519150601f19603f3d011682016040523d82523d6000602084013e611286565b606091505b5091509150816112cd577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001631156113bf57846001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d8060008114611372576040519150601f19603f3d011682016040523d82523d6000602084013e611377565b606091505b509092509050816113bf577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b50505095945050505050565b60006107736113d8611b37565b85858533611151565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b60008061141787611894565b905060006040518060400160405280601081526020016f67363d3d37363d34f03d5260086018f360801b81525090506000828251602084016000f590506001600160a01b0381166114a65760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405183906001600160a01b038316907f2feea65dd4e9f9cbd86b74b7734210c59a1b2981b5b137bd0ee3e208200c906790600090a36114e58361088a565b93506000816001600160a01b031687600001518a60405161150691906122c0565b60006040518083038185875af1925050503d8060008114611543576040519150601f19603f3d011682016040523d82523d6000602084013e611548565b606091505b505090506115568186611bed565b6040516001600160a01b0386169060008051602061236a83398151915290600090a26060856001600160a01b031688602001518a60405161159791906122c0565b60006040518083038185875af1925050503d80600081146115d4576040519150601f19603f3d011682016040523d82523d6000602084013e6115d9565b606091505b50909250905081611621577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016311561171357866001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d80600081146116c6576040519150601f19603f3d011682016040523d82523d6000602084013e6116cb565b606091505b50909250905081611713577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b505050505095945050505050565b600061049961172e611b37565b86868686611151565b60006104998585858533611151565b6000610499611753611b37565b8686868661140b565b6000808360601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09250506001600160a01b0382166117fb5760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b6040516001600160a01b0383169060008051602061236a83398151915290600090a2600080836001600160a01b0316348660405161183991906122c0565b60006040518083038185875af1925050503d8060008114611876576040519150601f19603f3d011682016040523d82523d6000602084013e61187b565b606091505b509150915061188b828288611b91565b50505092915050565b60008060006118a284611c61565b909250905060008260028111156118bb576118bb612353565b1480156118d9575060008160028111156118d7576118d7612353565b145b156119175760408051336020820152469181019190915260608101859052608001604051602081830303815290604052805190602001209250611ac6565b600082600281111561192b5761192b612353565b1480156119495750600181600281111561194757611947612353565b145b1561196957611962338560009182526020526040902090565b9250611ac6565b600082600281111561197d5761197d612353565b036119c6576040516313b3a2a160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60018260028111156119da576119da612353565b1480156119f8575060008160028111156119f6576119f6612353565b145b15611a1157611962468560009182526020526040902090565b6001826002811115611a2557611a25612353565b148015611a4357506002816002811115611a4157611a41612353565b145b15611a8c576040516313b3a2a160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b611a94611b37565b8403611aa05783611ac3565b604080516020810186905201604051602081830303815290604052805190602001205b92505b5050919050565b6001600160a01b0381161580611aeb57506001600160a01b0381163b155b15611b345760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b50565b6040805143601f198101406020830152419282019290925260608101919091524260808201524460a08201524660c08201523360e08201526000906101000160405160208183030381529060405280519060200120905090565b821580611ba657506001600160a01b0381163b155b15611be8577f00000000000000000000000000000000000000000000000000000000000000008260405163a57ca23960e01b8152600401610525929190612311565b505050565b811580611c0157506001600160a01b038116155b80611c1457506001600160a01b0381163b155b15611c5d5760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b5050565b600080606083901c33148015611c8a57508260141a60f81b6001600160f81b031916600160f81b145b15611c9a57506000905080915091565b606083901c33148015611cbc57506001600160f81b0319601484901a60f81b16155b15611ccd5750600090506001915091565b33606084901c03611ce45750600090506002915091565b606083901c158015611d0957508260141a60f81b6001600160f81b031916600160f81b145b15611d1a5750600190506000915091565b606083901c158015611d3b57506001600160f81b0319601484901a60f81b16155b15611d4b57506001905080915091565b606083901c611d605750600190506002915091565b8260141a60f81b6001600160f81b031916600160f81b03611d875750600290506000915091565b8260141a60f81b6001600160f81b031916600003611dab5750600290506001915091565b506002905080915091565b634e487b7160e01b600052604160045260246000fd5b600082601f830112611ddd57600080fd5b81356001600160401b0380821115611df757611df7611db6565b604051601f8301601f19908116603f01168101908282118183101715611e1f57611e1f611db6565b81604052838152866020858801011115611e3857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060408284031215611e6a57600080fd5b604051604081018181106001600160401b0382111715611e8c57611e8c611db6565b604052823581526020928301359281019290925250919050565b60008060008060a08587031215611ebc57600080fd5b8435935060208501356001600160401b0380821115611eda57600080fd5b611ee688838901611dcc565b94506040870135915080821115611efc57600080fd5b50611f0987828801611dcc565b925050611f198660608701611e58565b905092959194509250565b80356001600160a01b0381168114611f3b57600080fd5b919050565b600060208284031215611f5257600080fd5b610d1082611f24565b60008060408385031215611f6e57600080fd5b8235915060208301356001600160401b03811115611f8b57600080fd5b611f9785828601611dcc565b9150509250929050565b600060208284031215611fb357600080fd5b81356001600160401b03811115611fc957600080fd5b61077384828501611dcc565b600080600060608486031215611fea57600080fd5b83359250611ffa60208501611f24565b915060408401356001600160401b0381111561201557600080fd5b61202186828701611dcc565b9150509250925092565b60006020828403121561203d57600080fd5b5035919050565b60008060006080848603121561205957600080fd5b83356001600160401b038082111561207057600080fd5b61207c87838801611dcc565b9450602086013591508082111561209257600080fd5b5061209f86828701611dcc565b9250506120af8560408601611e58565b90509250925092565b600080604083850312156120cb57600080fd5b823591506120db60208401611f24565b90509250929050565b600080604083850312156120f757600080fd5b61210083611f24565b946020939093013593505050565b6000806040838503121561212157600080fd5b61212a83611f24565b915060208301356001600160401b03811115611f8b57600080fd5b6000806040838503121561215857600080fd5b50508035926020909101359150565b60008060008060a0858703121561217d57600080fd5b84356001600160401b038082111561219457600080fd5b6121a088838901611dcc565b955060208701359150808211156121b657600080fd5b506121c387828801611dcc565b9350506121d38660408701611e58565b9150611f1960808601611f24565b600080600080600060c086880312156121f957600080fd5b8535945060208601356001600160401b038082111561221757600080fd5b61222389838a01611dcc565b9550604088013591508082111561223957600080fd5b5061224688828901611dcc565b9350506122568760608801611e58565b915061226460a08701611f24565b90509295509295909350565b60008060006060848603121561228557600080fd5b83359250602084013591506120af60408501611f24565b60005b838110156122b757818101518382015260200161229f565b50506000910152565b600082516122d281846020870161229c565b9190910192915050565b6001600160401b0382811682821603908082111561230a57634e487b7160e01b600052601160045260246000fd5b5092915050565b60018060a01b0383168152604060208201526000825180604084015261233e81606085016020870161229c565b601f01601f1916919091016060019392505050565b634e487b7160e01b600052602160045260246000fdfe4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511a2646970667358221220615d16bec0a45fac2d0a7d9210718f14f6b99bcf447c174e1f969d662bf4493764736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106101b65760003560e01c806381503da1116100ec578063c3fe107b1161008a578063e437252a11610064578063e437252a1461043e578063e96deee414610451578063f5745aba14610464578063f96644981461047757600080fd5b8063c3fe107b146103f8578063d323826a1461040b578063ddda0acb1461042b57600080fd5b806398e81077116100c657806398e810771461039f5780639c36a286146103b2578063a49a7c90146103c5578063a7db93f2146103e557600080fd5b806381503da11461034c57806385cf97ab1461035f578063890c283b1461037f57600080fd5b80632f990e3f1161015957806364e030871161013357806364e03087146102e65780636cec2536146102f957806374637a7a146103195780637f5653601461033957600080fd5b80632f990e3f146102a057806331a7c8c8146102b357806342d654fc146102c657600080fd5b806326a32fc71161019557806326a32fc71461024757806327fe18221461025a5780632852527a1461026d57806328ddd0461461028057600080fd5b8062d84acb146101bb57806308508b8f146101eb5780632630766814610234575b600080fd5b6101ce6101c9366004611ea6565b61048a565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156101f757600080fd5b50610224610206366004611f40565b6001600160a01b031660009081526020819052604090205460ff1690565b60405190151581526020016101e2565b6101ce610242366004611f5b565b6104a2565b6101ce610255366004611fa1565b610580565b6101ce610268366004611fa1565b610599565b6101ce61027b366004611fd5565b6105d5565b34801561028c57600080fd5b506101ce61029b36600461202b565b610731565b6101ce6102ae366004612044565b61075d565b6101ce6102c1366004612044565b61077b565b3480156102d257600080fd5b506101ce6102e13660046120b8565b610789565b6101ce6102f4366004611f5b565b6107e3565b34801561030557600080fd5b506101ce61031436600461202b565b61088a565b34801561032557600080fd5b506101ce6103343660046120e4565b6108b6565b6101ce610347366004611fa1565b610ce9565b6101ce61035a36600461210e565b610cfc565b34801561036b57600080fd5b506101ce61037a366004611f5b565b610d17565b34801561038b57600080fd5b506101ce61039a366004612145565b610d9f565b6101ce6103ad366004612167565b610dcc565b6101ce6103c0366004611f5b565b610fa9565b3480156103d157600080fd5b506101ce6103e0366004612145565b61111c565b6101ce6103f33660046121e1565b611151565b6101ce610406366004612044565b6113cb565b34801561041757600080fd5b506101ce610426366004612270565b6113e1565b6101ce6104393660046121e1565b61140b565b6101ce61044c366004612167565b611721565b6101ce61045f366004611ea6565b611737565b6101ce610472366004612167565b611746565b6101ce61048536600461210e565b61175c565b6000610499858585853361140b565b95945050505050565b6000806104ae84611894565b90508083516020850134f591506104c482611acd565b6001600160a01b03821660009081526020819052604090205460ff161561052e5760405163602e773d60e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660048201526024015b60405180910390fd5b6001600160a01b038216600081815260208190526040808220805460ff19166001179055518392917fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f791a35092915050565b600061059361058d611b37565b836104a2565b92915050565b600081516020830134f090506105ae81611acd565b6040516001600160a01b0382169060008051602061236a83398151915290600090a2919050565b6000806105e185611894565b905060008460601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b6028820152826037826000f59350506001600160a01b0383166106825760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405182906001600160a01b038516907fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f790600090a3600080846001600160a01b031634876040516106d491906122c0565b60006040518083038185875af1925050503d8060008114610711576040519150601f19603f3d011682016040523d82523d6000602084013e610716565b606091505b5091509150610726828289611b91565b505050509392505050565b60006105937f0000000000000000000000000000000000000000000000000000000000000000836108b6565b600061077361076a611b37565b8585853361140b565b949350505050565b600061077384848433610dcc565b60006040518260005260ff600b53836020527f21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f6040526055600b20601452806040525061d694600052600160345350506017601e20919050565b600082606081901c33148061080057506001600160601b03198116155b6108805760405162461bcd60e51b815260206004820152604560248201527f496e76616c69642073616c74202d206669727374203230206279746573206f6660448201527f207468652073616c74206d757374206d617463682063616c6c696e67206164646064820152643932b9b99760d91b608482015260a401610525565b61077384846104a2565b6000610593827f0000000000000000000000000000000000000000000000000000000000000000610789565b60006060602560fa1b6108d160016001600160401b036122dc565b6001600160401b031684111561092557604051633c55ab3b60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b8360000361098257604051606b60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152600160ff1b60368201526037015b6040516020818303038152906040529150610cd9565b607f84116109cf57604051606b60f91b60208201526001600160f81b031980831660218301526001600160601b0319606088901b16602283015260f886901b16603682015260370161096c565b60ff8411610a265760405160d760f81b60208201526001600160f81b031980831660218301526001600160601b0319606088901b166022830152608160f81b603683015260f886901b16603782015260380161096c565b61ffff8411610a8657604051601b60fb1b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152604160f91b60368201526001600160f01b031960f086901b16603782015260390161096c565b62ffffff8411610ae75760405160d960f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608360f81b60368201526001600160e81b031960e886901b166037820152603a0161096c565b63ffffffff8411610b4957604051606d60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152602160fa1b60368201526001600160e01b031960e086901b166037820152603b0161096c565b64ffffffffff8411610bac5760405160db60f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608560f81b60368201526001600160d81b031960d886901b166037820152603c0161096c565b65ffffffffffff8411610c1057604051603760fa1b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152604360f91b60368201526001600160d01b031960d086901b166037820152603d0161096c565b66ffffffffffffff8411610c755760405160dd60f81b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152608760f81b60368201526001600160c81b031960c886901b166037820152603e0161096c565b604051606f60f91b60208201526001600160f81b0319821660218201526001600160601b0319606087901b166022820152601160fb1b60368201526001600160c01b031960c086901b166037820152603f0160405160208183030381529060405291505b5080516020909101209392505050565b6000610593610cf6611b37565b83610fa9565b6000610d10610d09611b37565b84846105d5565b9392505050565b6000610d72610d2584611894565b83604051602001610d3691906122c0565b604051602081830303815290604052805190602001207f00000000000000000000000000000000000000000000000000000000000000006113e1565b6001600160a01b03811660009081526020819052604090205490915060ff16156105935750600092915050565b6000610d1083837f00000000000000000000000000000000000000000000000000000000000000006113e1565b60008451602086018451f09050610de281611acd565b6040516001600160a01b0382169060008051602061236a83398151915290600090a2600080826001600160a01b0316856020015187604051610e2491906122c0565b60006040518083038185875af1925050503d8060008114610e61576040519150601f19603f3d011682016040523d82523d6000602084013e610e66565b606091505b509150915081610ead577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163115610f9f57836001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d8060008114610f52576040519150601f19603f3d011682016040523d82523d6000602084013e610f57565b606091505b50909250905081610f9f577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b5050949350505050565b600080610fb584611894565b905060006040518060400160405280601081526020016f67363d3d37363d34f03d5260086018f360801b81525090506000828251602084016000f590506001600160a01b0381166110445760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405183906001600160a01b038316907f2feea65dd4e9f9cbd86b74b7734210c59a1b2981b5b137bd0ee3e208200c906790600090a36110838361088a565b93506000816001600160a01b031634876040516110a091906122c0565b60006040518083038185875af1925050503d80600081146110dd576040519150601f19603f3d011682016040523d82523d6000602084013e6110e2565b606091505b505090506110f08186611bed565b6040516001600160a01b0386169060008051602061236a83398151915290600090a25050505092915050565b6000610d7261112a84611894565b837f00000000000000000000000000000000000000000000000000000000000000006113e1565b60008061115d87611894565b9050808651602088018651f5915061117482611acd565b6001600160a01b03821660009081526020819052604090205460ff16156111d95760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b6001600160a01b038216600081815260208190526040808220805460ff19166001179055518392917fb8fda7e00c6b06a2b54e58521bc5894fee35f1090e5a3bb6390bfe2b98b497f791a3600080836001600160a01b031686602001518860405161124491906122c0565b60006040518083038185875af1925050503d8060008114611281576040519150601f19603f3d011682016040523d82523d6000602084013e611286565b606091505b5091509150816112cd577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001631156113bf57846001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d8060008114611372576040519150601f19603f3d011682016040523d82523d6000602084013e611377565b606091505b509092509050816113bf577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b50505095945050505050565b60006107736113d8611b37565b85858533611151565b6000604051836040820152846020820152828152600b8101905060ff815360559020949350505050565b60008061141787611894565b905060006040518060400160405280601081526020016f67363d3d37363d34f03d5260086018f360801b81525090506000828251602084016000f590506001600160a01b0381166114a65760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60405183906001600160a01b038316907f2feea65dd4e9f9cbd86b74b7734210c59a1b2981b5b137bd0ee3e208200c906790600090a36114e58361088a565b93506000816001600160a01b031687600001518a60405161150691906122c0565b60006040518083038185875af1925050503d8060008114611543576040519150601f19603f3d011682016040523d82523d6000602084013e611548565b606091505b505090506115568186611bed565b6040516001600160a01b0386169060008051602061236a83398151915290600090a26060856001600160a01b031688602001518a60405161159791906122c0565b60006040518083038185875af1925050503d80600081146115d4576040519150601f19603f3d011682016040523d82523d6000602084013e6115d9565b606091505b50909250905081611621577f00000000000000000000000000000000000000000000000000000000000000008160405163a57ca23960e01b8152600401610525929190612311565b6001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016311561171357866001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03163160405160006040518083038185875af1925050503d80600081146116c6576040519150601f19603f3d011682016040523d82523d6000602084013e6116cb565b606091505b50909250905081611713577f00000000000000000000000000000000000000000000000000000000000000008160405163c2b3f44560e01b8152600401610525929190612311565b505050505095945050505050565b600061049961172e611b37565b86868686611151565b60006104998585858533611151565b6000610499611753611b37565b8686868661140b565b6000808360601b9050604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528160148201526e5af43d82803e903d91602b57fd5bf360881b60288201526037816000f09250506001600160a01b0382166117fb5760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b6040516001600160a01b0383169060008051602061236a83398151915290600090a2600080836001600160a01b0316348660405161183991906122c0565b60006040518083038185875af1925050503d8060008114611876576040519150601f19603f3d011682016040523d82523d6000602084013e61187b565b606091505b509150915061188b828288611b91565b50505092915050565b60008060006118a284611c61565b909250905060008260028111156118bb576118bb612353565b1480156118d9575060008160028111156118d7576118d7612353565b145b156119175760408051336020820152469181019190915260608101859052608001604051602081830303815290604052805190602001209250611ac6565b600082600281111561192b5761192b612353565b1480156119495750600181600281111561194757611947612353565b145b1561196957611962338560009182526020526040902090565b9250611ac6565b600082600281111561197d5761197d612353565b036119c6576040516313b3a2a160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b60018260028111156119da576119da612353565b1480156119f8575060008160028111156119f6576119f6612353565b145b15611a1157611962468560009182526020526040902090565b6001826002811115611a2557611a25612353565b148015611a4357506002816002811115611a4157611a41612353565b145b15611a8c576040516313b3a2a160e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b611a94611b37565b8403611aa05783611ac3565b604080516020810186905201604051602081830303815290604052805190602001205b92505b5050919050565b6001600160a01b0381161580611aeb57506001600160a01b0381163b155b15611b345760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b50565b6040805143601f198101406020830152419282019290925260608101919091524260808201524460a08201524660c08201523360e08201526000906101000160405160208183030381529060405280519060200120905090565b821580611ba657506001600160a01b0381163b155b15611be8577f00000000000000000000000000000000000000000000000000000000000000008260405163a57ca23960e01b8152600401610525929190612311565b505050565b811580611c0157506001600160a01b038116155b80611c1457506001600160a01b0381163b155b15611c5d5760405163602e773d60e11b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000166004820152602401610525565b5050565b600080606083901c33148015611c8a57508260141a60f81b6001600160f81b031916600160f81b145b15611c9a57506000905080915091565b606083901c33148015611cbc57506001600160f81b0319601484901a60f81b16155b15611ccd5750600090506001915091565b33606084901c03611ce45750600090506002915091565b606083901c158015611d0957508260141a60f81b6001600160f81b031916600160f81b145b15611d1a5750600190506000915091565b606083901c158015611d3b57506001600160f81b0319601484901a60f81b16155b15611d4b57506001905080915091565b606083901c611d605750600190506002915091565b8260141a60f81b6001600160f81b031916600160f81b03611d875750600290506000915091565b8260141a60f81b6001600160f81b031916600003611dab5750600290506001915091565b506002905080915091565b634e487b7160e01b600052604160045260246000fd5b600082601f830112611ddd57600080fd5b81356001600160401b0380821115611df757611df7611db6565b604051601f8301601f19908116603f01168101908282118183101715611e1f57611e1f611db6565b81604052838152866020858801011115611e3857600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060408284031215611e6a57600080fd5b604051604081018181106001600160401b0382111715611e8c57611e8c611db6565b604052823581526020928301359281019290925250919050565b60008060008060a08587031215611ebc57600080fd5b8435935060208501356001600160401b0380821115611eda57600080fd5b611ee688838901611dcc565b94506040870135915080821115611efc57600080fd5b50611f0987828801611dcc565b925050611f198660608701611e58565b905092959194509250565b80356001600160a01b0381168114611f3b57600080fd5b919050565b600060208284031215611f5257600080fd5b610d1082611f24565b60008060408385031215611f6e57600080fd5b8235915060208301356001600160401b03811115611f8b57600080fd5b611f9785828601611dcc565b9150509250929050565b600060208284031215611fb357600080fd5b81356001600160401b03811115611fc957600080fd5b61077384828501611dcc565b600080600060608486031215611fea57600080fd5b83359250611ffa60208501611f24565b915060408401356001600160401b0381111561201557600080fd5b61202186828701611dcc565b9150509250925092565b60006020828403121561203d57600080fd5b5035919050565b60008060006080848603121561205957600080fd5b83356001600160401b038082111561207057600080fd5b61207c87838801611dcc565b9450602086013591508082111561209257600080fd5b5061209f86828701611dcc565b9250506120af8560408601611e58565b90509250925092565b600080604083850312156120cb57600080fd5b823591506120db60208401611f24565b90509250929050565b600080604083850312156120f757600080fd5b61210083611f24565b946020939093013593505050565b6000806040838503121561212157600080fd5b61212a83611f24565b915060208301356001600160401b03811115611f8b57600080fd5b6000806040838503121561215857600080fd5b50508035926020909101359150565b60008060008060a0858703121561217d57600080fd5b84356001600160401b038082111561219457600080fd5b6121a088838901611dcc565b955060208701359150808211156121b657600080fd5b506121c387828801611dcc565b9350506121d38660408701611e58565b9150611f1960808601611f24565b600080600080600060c086880312156121f957600080fd5b8535945060208601356001600160401b038082111561221757600080fd5b61222389838a01611dcc565b9550604088013591508082111561223957600080fd5b5061224688828901611dcc565b9350506122568760608801611e58565b915061226460a08701611f24565b90509295509295909350565b60008060006060848603121561228557600080fd5b83359250602084013591506120af60408501611f24565b60005b838110156122b757818101518382015260200161229f565b50506000910152565b600082516122d281846020870161229c565b9190910192915050565b6001600160401b0382811682821603908082111561230a57634e487b7160e01b600052601160045260246000fd5b5092915050565b60018060a01b0383168152604060208201526000825180604084015261233e81606085016020870161229c565b601f01601f1916919091016060019392505050565b634e487b7160e01b600052602160045260246000fdfe4db17dd5e4732fb6da34a148104a592783ca119a1e7bb8829eba6cbadef0b511a2646970667358221220615d16bec0a45fac2d0a7d9210718f14f6b99bcf447c174e1f969d662bf4493764736f6c63430008140033",
  "devdoc": {
    "author": "RARIBLE team",
    "custom:based-on": "Implementation by pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/) and Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/), modified by RARIBLE team for specific use cases.",
    "details": "To simplify testing of non-public variables and functions, we use the `internal` function visibility specifier `internal` for all variables and functions, even though they could technically be `private` since we do not expect anyone to inherit from the `CreateX` contract.",
    "errors": {
      "FailedContractCreation(address)": [
        {
          "details": "Error that occurs when the contract creation failed.",
          "params": {
            "emitter": "The contract that emits the error."
          }
        }
      ],
      "FailedContractInitialisation(address,bytes)": [
        {
          "details": "Error that occurs when the contract initialisation call failed.",
          "params": {
            "emitter": "The contract that emits the error.",
            "revertData": "The data returned by the failed initialisation call."
          }
        }
      ],
      "FailedEtherTransfer(address,bytes)": [
        {
          "details": "Error that occurs when transferring ether has failed.",
          "params": {
            "emitter": "The contract that emits the error.",
            "revertData": "The data returned by the failed ether transfer."
          }
        }
      ],
      "InvalidNonceValue(address)": [
        {
          "details": "Error that occurs when the nonce value is invalid.",
          "params": {
            "emitter": "The contract that emits the error."
          }
        }
      ],
      "InvalidSalt(address)": [
        {
          "details": "Error that occurs when the salt value is invalid.",
          "params": {
            "emitter": "The contract that emits the error."
          }
        }
      ]
    },
    "events": {
      "ContractCreation(address)": {
        "details": "Event that is emitted when a contract is successfully created.",
        "params": {
          "newContract": "The address of the new contract."
        }
      },
      "ContractCreation(address,bytes32)": {
        "details": "Event that is emitted when a contract is successfully created.",
        "params": {
          "newContract": "The address of the new contract.",
          "salt": "The 32-byte random value used to create the contract address."
        }
      },
      "Create3ProxyContractCreation(address,bytes32)": {
        "details": "Event that is emitted when a `CREATE3` proxy contract is successfully created.",
        "params": {
          "newContract": "The address of the new proxy contract.",
          "salt": "The 32-byte random value used to create the proxy address."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "computeCreate2Address(bytes32,bytes32)": {
        "details": "Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.",
        "params": {
          "initCodeHash": "The 32-byte bytecode digest of the contract creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "computeCreate2Address(bytes32,bytes32,address)": {
        "details": "Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address. This implementation is based on OpenZeppelin: https://web.archive.org/web/20230921113703/https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/Create2.sol.",
        "params": {
          "deployer": "The 20-byte deployer address.",
          "initCodeHash": "The 32-byte bytecode digest of the contract creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "computeCreate3Address(bytes32)": {
        "details": "Returns the address where a contract will be stored if deployed via this contract using the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will result in a new destination address. This implementation is based on Solady: https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.",
        "params": {
          "salt": "The 32-byte random value used to create the proxy contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "computeCreate3Address(bytes32,address)": {
        "details": "Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will result in a new destination address. This implementation is based on Solady: https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.",
        "params": {
          "deployer": "The 20-byte deployer address.",
          "salt": "The 32-byte random value used to create the proxy contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "computeCreateAddress(address,uint256)": {
        "details": "Returns the address where a contract will be stored if deployed via `deployer` using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf) and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/). For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207. Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification, all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the first contract address created by another contract is calculated with a non-zero nonce.",
        "params": {
          "deployer": "The 20-byte deployer address.",
          "nonce": "The next 32-byte nonce of the deployer address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "computeCreateAddress(uint256)": {
        "details": "Returns the address where a contract will be stored if deployed via this contract using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf) and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/). For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207. Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification, all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the first contract address created by another contract is calculated with a non-zero nonce.",
        "params": {
          "nonce": "The next 32-byte nonce of this contract."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "deployCreate(bytes)": {
        "details": "Deploys a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "initCode": "The creation bytecode."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2(bytes)": {
        "details": "Deploys a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode` and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "initCode": "The creation bytecode."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2(bytes32,bytes)": {
        "details": "Deploys a new contract via calling the `CREATE2` opcode and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "initCode": "The creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2AndInit(bytes,bytes,(uint256,uint256))": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2AndInit(bytes,bytes,(uint256,uint256),address)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE2` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "refundAddress": "The 20-byte address where any excess ether is returned to.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2AndInit(bytes32,bytes,bytes,(uint256,uint256))": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE2` opcode and using the salt value `salt`, creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2AndInit(bytes32,bytes,bytes,(uint256,uint256),address)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE2` opcode and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "refundAddress": "The 20-byte address where any excess ether is returned to.",
          "salt": "The 32-byte random value used to create the contract address.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate2Clone(address,bytes)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt value `salt`, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed proxy contract.",
          "implementation": "The 20-byte implementation contract address."
        },
        "returns": {
          "proxy": "The 20-byte address where the clone was deployed."
        }
      },
      "deployCreate2Clone(bytes32,address,bytes)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt value `salt`, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed proxy contract.",
          "implementation": "The 20-byte implementation contract address.",
          "salt": "The 32-byte random value used to create the proxy contract address."
        },
        "returns": {
          "proxy": "The 20-byte address where the clone was deployed."
        }
      },
      "deployCreate3(bytes)": {
        "details": "Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "initCode": "The creation bytecode."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate3(bytes32,bytes)": {
        "custom:security": "We strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.",
        "details": "Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "initCode": "The creation bytecode.",
          "salt": "The 32-byte random value used to create the proxy contract address."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate3AndInit(bytes,bytes,(uint256,uint256))": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate3AndInit(bytes,bytes,(uint256,uint256),address)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and transaction properties. This approach does not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "refundAddress": "The 20-byte address where any excess ether is returned to.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate3AndInit(bytes32,bytes,bytes,(uint256,uint256))": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system. Furthermore, we strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.",
        "details": "Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "salt": "The 32-byte random value used to create the proxy contract address.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreate3AndInit(bytes32,bytes,bytes,(uint256,uint256),address)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system. Furthermore, we strongly recommend implementing a permissioned deploy protection by setting the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun proxy deployments on other chains.",
        "details": "Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate: https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "refundAddress": "The 20-byte address where any excess ether is returned to.",
          "salt": "The 32-byte random value used to create the proxy contract address.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreateAndInit(bytes,bytes,(uint256,uint256))": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreateAndInit(bytes,bytes,(uint256,uint256),address)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys and initialises a new contract via calling the `CREATE` opcode and using the creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.",
        "params": {
          "data": "The initialisation code that is passed to the deployed contract.",
          "initCode": "The creation bytecode.",
          "refundAddress": "The 20-byte address where any excess ether is returned to.",
          "values": "The specific `payable` amounts for the deployment and initialisation call."
        },
        "returns": {
          "newContract": "The 20-byte address where the contract was deployed."
        }
      },
      "deployCreateClone(address,bytes)": {
        "custom:security": "This function allows for reentrancy, however we refrain from adding a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol level that potentially malicious reentrant calls do not affect your smart contract system.",
        "details": "Deploys a new EIP-1167 minimal proxy contract using the `CREATE` opcode, and initialises the implementation contract using the implementation address `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.",
        "params": {
          "data": "The initialisation code that is passed to the deployed proxy contract.",
          "implementation": "The 20-byte implementation contract address."
        },
        "returns": {
          "proxy": "The 20-byte address where the clone was deployed."
        }
      },
      "findCreate2Address(bytes32,bytes)": {
        "details": "Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.",
        "params": {
          "initCode": "The 32-byte bytecode digest of the contract creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "findCreate2AddressViaHash(bytes32,bytes32)": {
        "details": "Returns the address where a contract will be stored if deployed via this contract using the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new destination address.",
        "params": {
          "initCodeHash": "The 32-byte bytecode digest of the contract creation bytecode.",
          "salt": "The 32-byte random value used to create the contract address."
        },
        "returns": {
          "computedAddress": "The 20-byte address where a contract will be stored."
        }
      },
      "hasBeenDeployed(address)": {
        "details": "Determine if a contract has already been deployed by the factory to a given address.",
        "params": {
          "deploymentAddress": "address The contract address to check."
        },
        "returns": {
          "_0": "True if the contract has been deployed, false otherwise."
        }
      },
      "safeCreate2(bytes32,bytes)": {
        "details": "Create a contract using CREATE2 by submitting a given salt or nonce along with the initialization code for the contract. Note that the first 20 bytes of the salt must match those of the calling address, which prevents contract creation events from being submitted by unintended parties.",
        "params": {
          "initCode": "bytes The initialization code that will be passed into the CREATE2 call.",
          "salt": "bytes32 The nonce that will be passed into the CREATE2 call."
        },
        "returns": {
          "newContract": "Address of the contract that will be created, or the null address if a contract already exists at that address."
        }
      }
    },
    "stateVariables": {
      "_SELF": {
        "details": "Caches the contract address at construction, to be used for the custom errors."
      }
    },
    "title": "CreateX Factory Smart Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Factory smart contract to make easier and safer usage of the `CREATE` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f0?fork=shanghai) and `CREATE2` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f5?fork=shanghai) EVM opcodes as well as of `CREATE3`-based (https://web.archive.org/web/20230921103920/https://github.com/ethereum/EIPs/pull/3171) contract creations.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 2179,
        "contract": "contracts/RaribleCreateX.sol:RaribleCreateX",
        "label": "_create2Deployed",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}