{
  "language": "Solidity",
  "sources": {
    "contracts/CreateX.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.20;\n\n/**\n * @title CreateX Factory Smart Contract\n * @author RARIBLE team\n * @notice Factory smart contract to make easier and safer usage of the\n * `CREATE` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f0?fork=shanghai) and `CREATE2`\n * (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f5?fork=shanghai) EVM opcodes as well as of\n * `CREATE3`-based (https://web.archive.org/web/20230921103920/https://github.com/ethereum/EIPs/pull/3171) contract creations.\n * @dev To simplify testing of non-public variables and functions, we use the `internal`\n * function visibility specifier `internal` for all variables and functions, even though\n * they could technically be `private` since we do not expect anyone to inherit from\n * the `CreateX` contract.\n * @custom:based-on Implementation by pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)\n * and Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/), modified by RARIBLE team\n * for specific use cases.\n */\ncontract CreateX {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Caches the contract address at construction, to be used for the custom errors.\n     */\n    address internal immutable _SELF = address(this);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CREATE2 MAPPING                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(address => bool) private _create2Deployed;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      CREATE2 MODIFIER                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\n     * those of the calling account. This provides protection against the salt\n     * being stolen by frontrunners or other attackers. The protection can also be\n     * bypassed if desired by setting each of the first 20 bytes to zero.\n     * @param salt bytes32 The salt value to check against the calling address.\n     * */\n    modifier containsCaller(bytes32 salt) {\n        // prevent contract submissions from being stolen from tx.pool by requiring\n        // that the first 20 bytes of the submitted salt match msg.sender.\n        require(\n        (address(bytes20(salt)) == msg.sender) ||\n        (bytes20(salt) == bytes20(0)),\n        \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n        );\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                            TYPES                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Struct for the `payable` amounts in a deploy-and-initialise call.\n     */\n    struct Values {\n        uint256 constructorAmount;\n        uint256 initCallAmount;\n    }\n\n    /**\n     * @dev Enum for the selection of a permissioned deploy protection.\n     */\n    enum SenderBytes {\n        MsgSender,\n        ZeroAddress,\n        Random\n    }\n\n    /**\n     * @dev Enum for the selection of a cross-chain redeploy protection.\n     */\n    enum RedeployProtectionFlag {\n        True,\n        False,\n        Unspecified\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Event that is emitted when a contract is successfully created.\n     * @param newContract The address of the new contract.\n     * @param salt The 32-byte random value used to create the contract address.\n     */\n    event ContractCreation(address indexed newContract, bytes32 indexed salt);\n\n    /**\n     * @dev Event that is emitted when a contract is successfully created.\n     * @param newContract The address of the new contract.\n     */\n    event ContractCreation(address indexed newContract);\n\n    /**\n     * @dev Event that is emitted when a `CREATE3` proxy contract is successfully created.\n     * @param newContract The address of the new proxy contract.\n     * @param salt The 32-byte random value used to create the proxy address.\n     */\n    event Create3ProxyContractCreation(address indexed newContract, bytes32 indexed salt);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Error that occurs when the contract creation failed.\n     * @param emitter The contract that emits the error.\n     */\n    error FailedContractCreation(address emitter);\n\n    /**\n     * @dev Error that occurs when the contract initialisation call failed.\n     * @param emitter The contract that emits the error.\n     * @param revertData The data returned by the failed initialisation call.\n     */\n    error FailedContractInitialisation(address emitter, bytes revertData);\n\n    /**\n     * @dev Error that occurs when the salt value is invalid.\n     * @param emitter The contract that emits the error.\n     */\n    error InvalidSalt(address emitter);\n\n    /**\n     * @dev Error that occurs when the nonce value is invalid.\n     * @param emitter The contract that emits the error.\n     */\n    error InvalidNonceValue(address emitter);\n\n    /**\n     * @dev Error that occurs when transferring ether has failed.\n     * @param emitter The contract that emits the error.\n     * @param revertData The data returned by the failed ether transfer.\n     */\n    error FailedEtherTransfer(address emitter, bytes revertData);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE` opcode and using the creation\n     * bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero,\n     * `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate(bytes memory initCode) public payable returns (address newContract) {\n        assembly (\"memory-safe\") {\n            newContract := create(callvalue(), add(initCode, 0x20), mload(initCode))\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to\n     * save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount`\n     * is non-zero, `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        assembly (\"memory-safe\") {\n            newContract := create(mload(values), add(initCode, 0x20), mload(initCode))\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        newContract = deployCreateAndInit({initCode: initCode, data: data, values: values, refundAddress: msg.sender});\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE` opcode, and initialises\n     * the implementation contract using the implementation address `implementation`, the initialisation\n     * code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser\n     * function called via `data` must be `payable`.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateClone(address implementation, bytes memory data) public payable returns (address proxy) {\n        bytes20 implementationInBytes = bytes20(implementation);\n        assembly (\"memory-safe\") {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                hex\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            mstore(add(clone, 0x14), implementationInBytes)\n            mstore(\n                add(clone, 0x28),\n                hex\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            proxy := create(0, clone, 0x37)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit ContractCreation({newContract: proxy});\n\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\n        _requireSuccessfulContractInitialisation({\n            success: success,\n            returnData: returnData,\n            implementation: implementation\n        });\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding\n     * scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\n     *\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\n     * first contract address created by another contract is calculated with a non-zero nonce.\n     * @param deployer The 20-byte deployer address.\n     * @param nonce The next 32-byte nonce of the deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreateAddress(address deployer, uint256 nonce) public view returns (address computedAddress) {\n        bytes memory data;\n        bytes1 len = bytes1(0x94);\n\n        // The theoretical allowed limit, based on EIP-2681, for an account nonce is 2**64-2:\n        // https://web.archive.org/web/20230921113252/https://eips.ethereum.org/EIPS/eip-2681.\n        if (nonce > type(uint64).max - 1) {\n            revert InvalidNonceValue({emitter: _SELF});\n        }\n\n        // The integer zero is treated as an empty byte string and therefore has only one length prefix,\n        // 0x80, which is calculated via 0x80 + 0.\n        if (nonce == 0x00) {\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, bytes1(0x80));\n        }\n        // A one-byte integer in the [0x00, 0x7f] range uses its own value as a length prefix, there is no\n        // additional \"0x80 + length\" prefix that precedes it.\n        else if (nonce <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, uint8(nonce));\n        }\n        // In the case of `nonce > 0x7f` and `nonce <= type(uint8).max`, we have the following encoding scheme\n        // (the same calculation can be carried over for higher nonce bytes):\n        // 0xda = 0xc0 (short RLP prefix) + 0x1a (= the bytes length of: 0x94 + address + 0x84 + nonce, in hex),\n        // 0x94 = 0x80 + 0x14 (= the bytes length of an address, 20 bytes, in hex),\n        // 0x84 = 0x80 + 0x04 (= the bytes length of the nonce, 4 bytes, in hex).\n        else if (nonce <= type(uint8).max) {\n            data = abi.encodePacked(bytes1(0xd7), len, deployer, bytes1(0x81), uint8(nonce));\n        } else if (nonce <= type(uint16).max) {\n            data = abi.encodePacked(bytes1(0xd8), len, deployer, bytes1(0x82), uint16(nonce));\n        } else if (nonce <= type(uint24).max) {\n            data = abi.encodePacked(bytes1(0xd9), len, deployer, bytes1(0x83), uint24(nonce));\n        } else if (nonce <= type(uint32).max) {\n            data = abi.encodePacked(bytes1(0xda), len, deployer, bytes1(0x84), uint32(nonce));\n        } else if (nonce <= type(uint40).max) {\n            data = abi.encodePacked(bytes1(0xdb), len, deployer, bytes1(0x85), uint40(nonce));\n        } else if (nonce <= type(uint48).max) {\n            data = abi.encodePacked(bytes1(0xdc), len, deployer, bytes1(0x86), uint48(nonce));\n        } else if (nonce <= type(uint56).max) {\n            data = abi.encodePacked(bytes1(0xdd), len, deployer, bytes1(0x87), uint56(nonce));\n        } else {\n            data = abi.encodePacked(bytes1(0xde), len, deployer, bytes1(0x88), uint64(nonce));\n        }\n\n        computedAddress = address(uint160(uint256(keccak256(data))));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract\n     * using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP)\n     * encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\n     *\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\n     * first contract address created by another contract is calculated with a non-zero nonce.\n     * @param nonce The next 32-byte nonce of this contract.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreateAddress(uint256 nonce) public view returns (address computedAddress) {\n        computedAddress = computeCreateAddress({deployer: _SELF, nonce: nonce});\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE2                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the salt value `salt`,\n     * the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode`\n     * must have a `payable` constructor.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate2(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        assembly (\"memory-safe\") {\n            newContract := create2(callvalue(), add(initCode, 0x20), mload(initCode), guardedSalt)\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\n        _create2Deployed[newContract] = true;\n\n\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\n    }\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the creation bytecode\n     * `initCode` and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\n     * diverse selection of block and transaction properties. This approach does not guarantee true\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate2(bytes memory initCode) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2`.\n        newContract = deployCreate2({salt: _generateSalt(), initCode: initCode});\n    }\n\n    /**\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\n     * along with the initialization code for the contract. Note that the first 20\n     * bytes of the salt must match those of the calling address, which prevents\n     * contract creation events from being submitted by unintended parties.\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\n     * @param initCode bytes The initialization code that will be passed\n     * into the CREATE2 call.\n     * @return newContract Address of the contract that will be created, or the null address\n     * if a contract already exists at that address.\n     */\n    function safeCreate2(bytes32 salt, bytes memory initCode) public payable containsCaller(salt) returns (address newContract) {\n        newContract = deployCreate2({salt: salt, initCode: initCode});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct\n     * for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs.\n     * In order to save deployment costs, we do not sanity check the `initCode` length. Note that if\n     * `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        assembly (\"memory-safe\") {\n            newContract := create2(mload(values), add(initCode, 0x20), mload(initCode), guardedSalt)\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\n        _create2Deployed[newContract] = true;\n\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\n\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * salt value `salt`, creation bytecode `initCode`, the initialisation code `data`, the struct for\n     * the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: salt,\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value\n     * is calculated pseudo-randomly using a diverse selection of block and transaction properties.\n     * This approach does not guarantee true randomness! In order to save deployment costs, we do not\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode`\n     * must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: refundAddress\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts\n     * `values`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\n     * diverse selection of block and transaction properties. This approach does not guarantee true\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\n     * value `salt`, and initialises the implementation contract using the implementation address\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if\n     * `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2Clone(\n        bytes32 salt,\n        address implementation,\n        bytes memory data\n    ) public payable returns (address proxy) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes20 implementationInBytes = bytes20(implementation);\n        assembly (\"memory-safe\") {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                hex\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            mstore(add(clone, 0x14), implementationInBytes)\n            mstore(\n                add(clone, 0x28),\n                hex\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            proxy := create2(0, clone, 0x37, guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit ContractCreation({newContract: proxy, salt: guardedSalt});\n\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\n        _requireSuccessfulContractInitialisation({\n            success: success,\n            returnData: returnData,\n            implementation: implementation\n        });\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\n     * value `salt`, and initialises the implementation contract using the implementation address\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. The salt value is\n     * calculated pseudo-randomly using a diverse selection of block and transaction properties. This\n     * approach does not guarantee true randomness! Note that if `msg.value` is non-zero, the initialiser\n     * function called via `data` must be `payable`.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2Clone(address implementation, bytes memory data) public payable returns (address proxy) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2Clone`.\n        proxy = deployCreate2Clone({salt: _generateSalt(), implementation: implementation, data: data});\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address. This implementation is based on OpenZeppelin:\n     * https://web.archive.org/web/20230921113703/https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/Create2.sol.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @param deployer The 20-byte deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash,\n        address deployer\n    ) public pure returns (address computedAddress) {\n        assembly (\"memory-safe\") {\n            // |                      | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |----------------------|---------------------------------------------------------------------------|\n            // | initCodeHash         |                                                        CCCCCCCCCCCCC...CC |\n            // | salt                 |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer             | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF                 |            FF                                                             |\n            // |----------------------|---------------------------------------------------------------------------|\n            // | memory               | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak256(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x40), initCodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer)\n            let start := add(ptr, 0x0b)\n            mstore8(start, 0xff)\n            computedAddress := keccak256(start, 85)\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function findCreate2AddressViaHash(bytes32 salt, bytes32 initCodeHash) public view returns (address computedAddress) {\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: initCodeHash, deployer: _SELF});\n        // return null address to signify failure if contract has been deployed.\n        if (_create2Deployed[computedAddress]) return address(0);\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The 32-byte bytecode digest of the contract creation bytecode.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function findCreate2Address(bytes32 salt, bytes memory initCode) public view returns (address computedAddress) {\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: keccak256(abi.encodePacked(initCode)), deployer: _SELF});\n        // return null address to signify failure if contract has been deployed.\n        if (_create2Deployed[computedAddress]) return address(0);\n    }\n\n    /**\n     * @dev Determine if a contract has already been deployed by the factory to a\n     * given address.\n     * @param deploymentAddress address The contract address to check.\n     * @return True if the contract has been deployed, false otherwise.\n     */\n    function hasBeenDeployed(address deploymentAddress) external view returns (bool) {\n        // determine if a contract has been deployed to the provided address.\n        return _create2Deployed[deploymentAddress];\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE3                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\n     * as inputs. In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This\n     * implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security We strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes memory proxyChildBytecode = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n        address proxy;\n        assembly (\"memory-safe\") {\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\n\n        newContract = computeCreate3Address({salt: guardedSalt});\n        (bool success, ) = proxy.call{value: msg.value}(initCode);\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n    }\n\n    /**\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block\n     * and transaction properties. This approach does not guarantee true randomness! In order to save\n     * deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is\n     * non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate3(bytes memory initCode) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3`.\n        newContract = deployCreate3({salt: _generateSalt(), initCode: initCode});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\n     * initialisation code `data`, the struct for the `payable` amounts `values`, the refund address\n     * `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity\n     * check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must\n     * have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes memory proxyChildBytecode = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n        address proxy;\n        assembly (\"memory-safe\") {\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\n\n        newContract = computeCreate3Address({salt: guardedSalt});\n        (bool success, ) = proxy.call{value: values.constructorAmount}(initCode);\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n\n        bytes memory returnData;\n        (success, returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\n     * initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as\n     * inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note\n     * that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: salt,\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\n     * the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value`\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and\n     * transaction properties. This approach does not guarantee true randomness! In order to save deployment\n     * costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: refundAddress\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\n     * the struct for the `payable` amounts `values`, `msg.value` as inputs. The salt value is calculated\n     * pseudo-randomly using a diverse selection of block and transaction properties. This approach does\n     * not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode`\n     * length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\n     * result in a new destination address. This implementation is based on Solady:\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param deployer The 20-byte deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate3Address(bytes32 salt, address deployer) public pure returns (address computedAddress) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(0x00, deployer)\n            mstore8(0x0b, 0xff)\n            mstore(0x20, salt)\n            mstore(\n                0x40,\n                hex\"21_c3_5d_be_1b_34_4a_24_88_cf_33_21_d6_ce_54_2f_8e_9f_30_55_44_ff_09_e4_99_3a_62_31_9a_49_7c_1f\"\n            )\n            mstore(0x14, keccak256(0x0b, 0x55))\n            mstore(0x40, ptr)\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01)\n            computedAddress := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\n     * result in a new destination address. This implementation is based on Solady:\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate3Address(bytes32 salt) public view returns (address computedAddress) {\n        computedAddress = computeCreate3Address({salt: salt, deployer: _SELF});\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      HELPER FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Implements different safeguarding mechanisms depending on the encoded values in the salt\n     * (`||` stands for byte-wise concatenation):\n     *   => salt (32 bytes) = 0xbebebebebebebebebebebebebebebebebebebebe||ff||1212121212121212121212\n     *   - The first 20 bytes (i.e. `bebebebebebebebebebebebebebebebebebebebe`) may be used to\n     *     implement a permissioned deploy protection by setting them equal to `msg.sender`,\n     *   - The 21st byte (i.e. `ff`) may be used to implement a cross-chain redeploy protection by\n     *     setting it equal to `0x01`,\n     *   - The last random 11 bytes (i.e. `1212121212121212121212`) allow for 2**88 bits of entropy\n     *     for mining a salt.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @return guardedSalt The guarded 32-byte random value used to create the contract address.\n     */\n    function _guard(bytes32 salt) internal view returns (bytes32 guardedSalt) {\n        (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) = _parseSalt({salt: salt});\n\n        if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.True) {\n            // Configures a permissioned deploy protection as well as a cross-chain redeploy protection.\n            guardedSalt = keccak256(abi.encode(msg.sender, block.chainid, salt));\n        } else if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.False) {\n            // Configures solely a permissioned deploy protection.\n            guardedSalt = _efficientHash({a: bytes32(uint256(uint160(msg.sender))), b: salt});\n        } else if (senderBytes == SenderBytes.MsgSender) {\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\n            revert InvalidSalt({emitter: _SELF});\n        } else if (senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.True) {\n            // Configures solely a cross-chain redeploy protection. In order to prevent a pseudo-randomly\n            // generated cross-chain redeploy protection, we enforce the zero address check for the first 20 bytes.\n            guardedSalt = _efficientHash({a: bytes32(block.chainid), b: salt});\n        } else if (\n            senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.Unspecified\n        ) {\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\n            revert InvalidSalt({emitter: _SELF});\n        } else {\n            // For the non-pseudo-random cases, the salt value `salt` is hashed to prevent the safeguard mechanisms\n            // from being bypassed. Otherwise, the salt value `salt` is not modified.\n            guardedSalt = (salt != _generateSalt()) ? keccak256(abi.encode(salt)) : salt;\n        }\n    }\n\n    /**\n     * @dev Returns the enum for the selection of a permissioned deploy protection as well as a\n     * cross-chain redeploy protection.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @return senderBytes The 8-byte enum for the selection of a permissioned deploy protection.\n     * @return redeployProtectionFlag The 8-byte enum for the selection of a cross-chain redeploy\n     * protection.\n     */\n    function _parseSalt(\n        bytes32 salt\n    ) internal view returns (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) {\n        if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.True);\n        } else if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.False);\n        } else if (address(bytes20(salt)) == msg.sender) {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.Unspecified);\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.True);\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.False);\n        } else if (address(bytes20(salt)) == address(0)) {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.Unspecified);\n        } else if (bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.True);\n        } else if (bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.False);\n        } else {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.Unspecified);\n        }\n    }\n\n    /**\n     * @dev Returns the `keccak256` hash of `a` and `b` after concatenation.\n     * @param a The first 32-byte value to be concatenated and hashed.\n     * @param b The second 32-byte value to be concatenated and hashed.\n     * @return hash The 32-byte `keccak256` hash of `a` and `b`.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            hash := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Generates pseudo-randomly a salt value using a diverse selection of block and\n     * transaction properties.\n     * @return salt The 32-byte pseudo-random salt value.\n     */\n    function _generateSalt() internal view returns (bytes32 salt) {\n        unchecked {\n            salt = keccak256(\n                abi.encode(\n                    // We don't use `block.number - 256` (the maximum value on the EVM) to accommodate\n                    // any chains that may try to reduce the amount of available historical block hashes.\n                    // We also don't subtract 1 to mitigate any risks arising from consecutive block\n                    // producers on a PoS chain. Therefore, we use `block.number - 32` as a reasonable\n                    // compromise, one we expect should work on most chains, which is 1 epoch on Ethereum\n                    // mainnet. Please note that if you use this function between the genesis block and block\n                    // number 31, the block property `blockhash` will return zero, but the returned salt value\n                    // `salt` will still have a non-zero value due to the hashing characteristic and the other\n                    // remaining properties.\n                    blockhash(block.number - 32),\n                    block.coinbase,\n                    block.number,\n                    block.timestamp,\n                    block.prevrandao,\n                    block.chainid,\n                    msg.sender\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Ensures that `newContract` is a non-zero byte contract.\n     * @param success The Boolean success condition.\n     * @param newContract The 20-byte address where the contract was deployed.\n     */\n    function _requireSuccessfulContractCreation(bool success, address newContract) internal view {\n        // Note that reverting if `newContract == address(0)` isn't strictly necessary here, as if\n        // the deployment fails, `success == false` should already hold. However, since the `CreateX`\n        // contract should be usable and safe on a wide range of chains, this check is cheap enough\n        // that there is no harm in including it (security > gas optimisations). It can potentially\n        // protect against unexpected chain behaviour or a hypothetical compiler bug that doesn't surface\n        // the call success status properly.\n        if (!success || newContract == address(0) || newContract.code.length == 0) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n    }\n\n    /**\n     * @dev Ensures that `newContract` is a non-zero byte contract.\n     * @param newContract The 20-byte address where the contract was deployed.\n     */\n    function _requireSuccessfulContractCreation(address newContract) internal view {\n        if (newContract == address(0) || newContract.code.length == 0) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n    }\n\n    /**\n     * @dev Ensures that the contract initialisation call to `implementation` has been successful.\n     * @param success The Boolean success condition.\n     * @param returnData The return data from the contract initialisation call.\n     * @param implementation The 20-byte address where the implementation was deployed.\n     */\n    function _requireSuccessfulContractInitialisation(\n        bool success,\n        bytes memory returnData,\n        address implementation\n    ) internal view {\n        if (!success || implementation.code.length == 0) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n    }\n}"
    },
    "contracts/ICreateX.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.4;\n\n/**\n * @title CreateX Factory Interface Definition\n * @author pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)\n * @custom:coauthor Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/)\n */\ninterface ICreateX {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                            TYPES                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    struct Values {\n        uint256 constructorAmount;\n        uint256 initCallAmount;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    event ContractCreation(address indexed newContract, bytes32 indexed salt);\n    event ContractCreation(address indexed newContract);\n    event Create3ProxyContractCreation(address indexed newContract, bytes32 indexed salt);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    error FailedContractCreation(address emitter);\n    error FailedContractInitialisation(address emitter, bytes revertData);\n    error InvalidSalt(address emitter);\n    error InvalidNonceValue(address emitter);\n    error FailedEtherTransfer(address emitter, bytes revertData);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function deployCreate(bytes memory initCode) external payable returns (address newContract);\n\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreateClone(address implementation, bytes memory data) external payable returns (address proxy);\n\n    function computeCreateAddress(address deployer, uint256 nonce) external view returns (address computedAddress);\n\n    function computeCreateAddress(uint256 nonce) external view returns (address computedAddress);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE2                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function deployCreate2(bytes32 salt, bytes memory initCode) external payable returns (address newContract);\n\n    function deployCreate2(bytes memory initCode) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate2Clone(\n        bytes32 salt,\n        address implementation,\n        bytes memory data\n    ) external payable returns (address proxy);\n\n    function deployCreate2Clone(address implementation, bytes memory data) external payable returns (address proxy);\n\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash,\n        address deployer\n    ) external pure returns (address computedAddress);\n\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external view returns (address computedAddress);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE3                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    function deployCreate3(bytes32 salt, bytes memory initCode) external payable returns (address newContract);\n\n    function deployCreate3(bytes memory initCode) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) external payable returns (address newContract);\n\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) external payable returns (address newContract);\n\n    function computeCreate3Address(bytes32 salt, address deployer) external pure returns (address computedAddress);\n\n    function computeCreate3Address(bytes32 salt) external view returns (address computedAddress);\n}"
    },
    "contracts/lib/solady/src/utils/LibClone.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Minimal proxy library.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)\n/// @author Minimal proxy by 0age (https://github.com/0age)\n/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie\n/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)\n/// @author Minimal ERC1967 proxy by jtriley-eth (https://github.com/jtriley-eth/minimum-viable-proxy)\n///\n/// @dev Minimal proxy:\n/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,\n/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,\n/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.\n///\n/// @dev Minimal proxy (PUSH0 variant):\n/// This is a new minimal proxy that uses the PUSH0 opcode introduced during Shanghai.\n/// It is optimized first for minimal runtime gas, then for minimal bytecode.\n/// The PUSH0 clone functions are intentionally postfixed with a jarring \"_PUSH0\" as\n/// many EVM chains may not support the PUSH0 opcode in the early months after Shanghai.\n/// Please use with caution.\n///\n/// @dev Clones with immutable args (CWIA):\n/// The implementation of CWIA here implements a `receive()` method that emits the\n/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,\n/// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards\n/// composability. The minimal proxy implementation does not offer this feature.\n///\n/// @dev Minimal ERC1967 proxy:\n/// An minimal ERC1967 proxy, intended to be upgraded with UUPS.\n/// This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n/// This proxy is automatically verified on Etherscan.\n///\n/// @dev ERC1967I proxy:\n/// An variant of the minimal ERC1967 proxy, with a special code path that activates\n/// if `calldatasize() == 1`. This code path skips the delegatecall and directly returns the\n/// `implementation` address. The returned implementation is guaranteed to be valid if the\n/// keccak256 of the proxy's code is equal to `ERC1967I_CODE_HASH`.\nlibrary LibClone {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 proxy.\n    bytes32 internal constant ERC1967_CODE_HASH =\n        0xaaa52c8cc8a0e3fd27ce756cc6b4e70c51423e9b597b11f32d3e49f8b1fc890d;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967I proxy.\n    bytes32 internal constant ERC1967I_CODE_HASH =\n        0xce700223c0d4cea4583409accfc45adac4a093b3519998a9cbbe1504dadba6f7;\n\n    /// @dev The keccak256 of the deployed code for the ERC1967 beacon proxy.\n    bytes32 internal constant ERC1967_BEACON_PROXY_CODE_HASH =\n        0x14044459af17bc4f0f5aa2f658cb692add77d1302c29fe2aebab005eea9d1162;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the clone.\n    error DeploymentFailed();\n\n    /// @dev The salt must start with either the zero address or `by`.\n    error SaltDoesNotStartWith();\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  MINIMAL PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a clone of `implementation`.\n    function clone(address implementation) internal returns (address instance) {\n        instance = clone(0, implementation);\n    }\n\n    /// @dev Deploys a clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the clone of `implementation`.\n    function initCode(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(result, 0x28), implementation)\n            mstore(add(result, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(result, 0x35) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL PROXY OPERATIONS (PUSH0 VARIANT)          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }\n\n    /// @dev Deploys a PUSH0 clone of `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic PUSH0 clone of `implementation` with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the initialization code of the PUSH0 clone of `implementation`.\n    function initCode_PUSH0(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(add(result, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(result, 0x26), implementation) // 20\n            mstore(add(result, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(result, 0x36) // Store the length.\n            mstore(0x40, add(result, 0x60)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the PUSH0 clone of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic PUSH0 clone of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*           CLONES WITH IMMUTABLE ARGS OPERATIONS            */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This implementation of CWIA differs from the original implementation.\n    // If the calldata is empty, it will emit a `ReceiveETH(uint256)` event and skip the `DELEGATECALL`.\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    function clone(address implementation, bytes memory data) internal returns (address instance) {\n        instance = clone(0, implementation, data);\n    }\n\n    /// @dev Deploys a clone of `implementation` with immutable arguments encoded in `data`.\n    /// Deposits `value` ETH during deployment.\n    function clone(uint256 value, address implementation, bytes memory data)\n        internal\n        returns (address instance)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n            // The `creationSize` is `extraLength + 108`\n            // The `runSize` is `creationSize - 10`.\n\n            /**\n             * ---------------------------------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                                                |\n             * ---------------------------------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 r       |                                                       |\n             * 81         | DUP2              | r 0 r     |                                                       |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                                                       |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                                                       |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code                            |\n             * f3         | RETURN            |           | [0..runSize): runtime code                            |\n             * ---------------------------------------------------------------------------------------------------|\n             * RUNTIME (98 bytes + extraLength)                                                                   |\n             * ---------------------------------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                    | Memory                                      |\n             * ---------------------------------------------------------------------------------------------------|\n             *                                                                                                    |\n             * ::: if no calldata, emit event & return w/o `DELEGATECALL` ::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 60 0x2c  | PUSH1 0x2c     | 0x2c cds                 |                                             |\n             * 57       | JUMPI          |                          |                                             |\n             * 34       | CALLVALUE      | cv                       |                                             |\n             * 3d       | RETURNDATASIZE | 0 cv                     |                                             |\n             * 52       | MSTORE         |                          | [0..0x20): callvalue                        |\n             * 7f sig   | PUSH32 0x9e..  | sig                      | [0..0x20): callvalue                        |\n             * 59       | MSIZE          | 0x20 sig                 | [0..0x20): callvalue                        |\n             * 3d       | RETURNDATASIZE | 0 0x20 sig               | [0..0x20): callvalue                        |\n             * a1       | LOG1           |                          | [0..0x20): callvalue                        |\n             * 00       | STOP           |                          | [0..0x20): callvalue                        |\n             * 5b       | JUMPDEST       |                          |                                             |\n             *                                                                                                    |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                      |                                             |\n             * 3d       | RETURNDATASIZE | 0 cds                    |                                             |\n             * 3d       | RETURNDATASIZE | 0 0 cds                  |                                             |\n             * 37       | CALLDATACOPY   |                          | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                        | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0                      | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0                    | [0..cds): calldata                          |\n             * 3d       | RETURNDATASIZE | 0 0 0 0                  | [0..cds): calldata                          |\n             * 61 extra | PUSH2 extra    | e 0 0 0 0                | [0..cds): calldata                          |\n             *                                                                                                    |\n             * ::: copy extra data to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 80       | DUP1           | e e 0 0 0 0              | [0..cds): calldata                          |\n             * 60 0x62  | PUSH1 0x62     | 0x62 e e 0 0 0 0         | [0..cds): calldata                          |\n             * 36       | CALLDATASIZE   | cds 0x62 e e 0 0 0 0     | [0..cds): calldata                          |\n             * 39       | CODECOPY       | e 0 0 0 0                | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 01       | ADD            | cds+e 0 0 0 0            | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | 0 cds+e 0 0 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 73 addr  | PUSH20 addr    | addr 0 cds+e 0 0 0 0     | [0..cds): calldata, [cds..cds+e): extraData |\n             * 5a       | GAS            | gas addr 0 cds+e 0 0 0 0 | [0..cds): calldata, [cds..cds+e): extraData |\n             * f4       | DELEGATECALL   | success 0 0              | [0..cds): calldata, [cds..cds+e): extraData |\n             *                                                                                                    |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0 0          | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3d       | RETURNDATASIZE | rds rds success 0 0      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 93       | SWAP4          | 0 rds success 0 rds      | [0..cds): calldata, [cds..cds+e): extraData |\n             * 80       | DUP1           | 0 0 rds success 0 rds    | [0..cds): calldata, [cds..cds+e): extraData |\n             * 3e       | RETURNDATACOPY | success 0 rds            | [0..rds): returndata                        |\n             *                                                                                                    |\n             * 60 0x60  | PUSH1 0x60     | 0x60 success 0 rds       | [0..rds): returndata                        |\n             * 57       | JUMPI          | 0 rds                    | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                          | [0..rds): returndata                        |\n             *                                                                                                    |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                    | [0..rds): returndata                        |\n             * f3       | RETURN         |                          | [0..rds): returndata                        |\n             * ---------------------------------------------------------------------------------------------------+\n             */\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create(value, sub(data, 0x4c), add(extraLength, 0x6c))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, data, salt);\n    }\n\n    /// @dev Deploys a deterministic clone of `implementation`\n    /// with immutable arguments encoded in `data` and `salt`.\n    function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory data,\n        bytes32 salt\n    ) internal returns (address instance) {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                // Do a out-of-gas revert if `extraLength` is too big. 0xffff - 0x62 + 0x01 = 0xff9e.\n                // The actual EVM limit may be smaller and may change over time.\n                sub(data, add(0x59, lt(extraLength, 0xff9e))),\n                or(shl(0x78, add(extraLength, 0x62)), 0xfd6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            instance := create2(value, sub(data, 0x4c), add(extraLength, 0x6c), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    function initCode(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let dataLength := mload(data)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            let o := add(result, 0x8c)\n            let end := add(o, dataLength)\n\n            // Copy the `data` into `result`.\n            for { let d := sub(add(data, 0x20), o) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(o, 0x20)\n                if iszero(lt(o, end)) { break }\n            }\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(add(result, 0x6c), 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(add(result, 0x5f), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                add(result, 0x4b),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                add(result, 0x32),\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                add(result, 0x12),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(end, shl(0xf0, extraLength))\n            mstore(add(end, 0x02), 0) // Zeroize the slot after the result.\n            mstore(result, add(extraLength, 0x6c)) // Store the length.\n            mstore(0x40, add(0x22, end)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the clone of `implementation`\n    /// using immutable arguments encoded in `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(address implementation, bytes memory data)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        assembly {\n            // Compute the boundaries of the data and cache the memory slots around it.\n            let mBefore3 := mload(sub(data, 0x60))\n            let mBefore2 := mload(sub(data, 0x40))\n            let mBefore1 := mload(sub(data, 0x20))\n            let dataLength := mload(data)\n            let dataEnd := add(add(data, 0x20), dataLength)\n            let mAfter1 := mload(dataEnd)\n\n            // Do a out-of-gas revert if `dataLength` is too big. 0xffff - 0x02 - 0x62 = 0xff9b.\n            // The actual EVM limit may be smaller and may change over time.\n            returndatacopy(returndatasize(), returndatasize(), gt(dataLength, 0xff9b))\n\n            // +2 bytes for telling how much data there is appended to the call.\n            let extraLength := add(dataLength, 2)\n\n            mstore(data, 0x5af43d3d93803e606057fd5bf3) // Write the bytecode before the data.\n            mstore(sub(data, 0x0d), implementation) // Write the address of the implementation.\n            // Write the rest of the bytecode.\n            mstore(\n                sub(data, 0x21),\n                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)\n            )\n            // `keccak256(\"ReceiveETH(uint256)\")`\n            mstore(\n                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\n            )\n            mstore(\n                sub(data, 0x5a),\n                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)\n            )\n            mstore(dataEnd, shl(0xf0, extraLength))\n\n            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))\n\n            // Restore the overwritten memory surrounding `data`.\n            mstore(dataEnd, mAfter1)\n            mstore(data, dataLength)\n            mstore(sub(data, 0x20), mBefore1)\n            mstore(sub(data, 0x40), mBefore2)\n            mstore(sub(data, 0x60), mBefore3)\n        }\n    }\n\n    /// @dev Returns the address of the deterministic clone of\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*              MINIMAL ERC1967 PROXY OPERATIONS              */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: The ERC1967 proxy here is intended to be upgraded with UUPS.\n    // This is NOT the same as ERC1967Factory's transparent proxy, which includes admin logic.\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    function deployERC1967(address implementation) internal returns (address instance) {\n        instance = deployERC1967(0, implementation);\n    }\n\n    /// @dev Deploys a minimal ERC1967 proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x60),\n                0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300\n            )\n            mstore(\n                add(result, 0x40),\n                0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc\n            )\n            mstore(add(result, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(result, 0x09), 0x603d3d8160223d3973)\n            mstore(result, 0x5f) // Store the length.\n            mstore(0x40, add(result, 0x80)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967 proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                 ERC1967I PROXY OPERATIONS                  */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This proxy has a special code path that activates if `calldatasize() == 1`.\n    // This code path skips the delegatecall and directly returns the `implementation` address.\n    // The returned implementation is guaranteed to be valid if the keccak256 of the\n    // proxy's code is equal to `ERC1967I_CODE_HASH`.\n\n    /// @dev Deploys a minimal ERC1967I proxy with `implementation`.\n    function deployERC1967I(address implementation) internal returns (address instance) {\n        instance = deployERC1967I(0, implementation);\n    }\n\n    /// @dev Deploys a ERC1967I proxy with `implementation`.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Deploys a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }\n\n    /// @dev Creates a deterministic ERC1967I proxy with `implementation` and `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 proxy of `implementation`.\n    function initCodeERC1967I(address implementation) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x74),\n                0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3\n            )\n            mstore(\n                add(result, 0x54),\n                0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4\n            )\n            mstore(add(result, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(result, 0x1d), implementation)\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\n            mstore(add(result, 0x94), 0)\n            mstore(result, 0x74) // Store the length.\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 proxy of `implementation`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967I proxy of `implementation`,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*            CONSTANT ERC1967 BOOTSTRAP OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: This enables an ERC1967 proxy to be deployed at a deterministic address\n    // independent of the implementation:\n    // ```\n    //     address bootstrap = LibClone.constantERC1967Bootstrap();\n    //     address instance = LibClone.deployDeterministicERC1967(0, bootstrap, salt);\n    //     LibClone.bootstrapConstantERC1967(bootstrap, implementation);\n    // ```\n\n    /// @dev Deploys the constant ERC1967 bootstrap if it has not been deployed.\n    function constantERC1967Bootstrap() internal returns (address bootstrap) {\n        bootstrap = constantERC1967BootstrapAddress();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                mstore(0x20, 0x0894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc55)\n                mstore(0x00, 0x60258060093d393df358357f36)\n                if iszero(create2(0, 0x13, 0x2e, 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the implementation address of the ERC1967 bootstrap for this contract.\n    function constantERC1967BootstrapAddress() internal view returns (address bootstrap) {\n        bytes32 hash = 0xfe1a42b9c571a6a8c083c94ac67b9cfd74e2582923426aa3b762e3431d717cd1;\n        bootstrap = predictDeterministicAddress(hash, bytes32(0), address(this));\n    }\n\n    /// @dev Replaces the implementation at `instance`.\n    function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, shr(96, shl(96, implementation)))\n            if iszero(call(gas(), instance, 0, 0x00, 0x20, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*          MINIMAL ERC1967 BEACON PROXY OPERATIONS           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // Note: If you use this proxy, you MUST make sure that the beacon is a\n    // valid ERC1967 beacon. This means that the beacon must always return a valid\n    // address upon a staticcall to `implementation()`, given sufficient gas.\n    // For performance, the deployment operations and the proxy assumes that the\n    // beacon is always valid and will NOT validate it.\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    function deployERC1967BeaconProxy(address beacon) internal returns (address instance) {\n        instance = deployERC1967BeaconProxy(0, beacon);\n    }\n\n    /// @dev Deploys a minimal ERC1967 beacon proxy.\n    /// Deposits `value` ETH during deployment.\n    function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Deploys a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }\n\n    /// @dev Creates a deterministic minimal ERC1967 beacon proxy with `salt`.\n    /// Deposits `value` ETH during deployment.\n    /// Note: This method is intended for use in ERC4337 factories,\n    /// which are expected to NOT revert if the proxy is already deployed.\n    function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the initialization code of the minimal ERC1967 beacon proxy.\n    function initCodeERC1967BeaconProxy(address beacon)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(\n                add(result, 0x74),\n                0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3\n            )\n            mstore(\n                add(result, 0x54),\n                0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c\n            )\n            mstore(add(result, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(result, 0x1d), beacon)\n            mstore(add(result, 0x09), 0x60523d8160223d3973)\n            mstore(add(result, 0x94), 0)\n            mstore(result, 0x74) // Store the length.\n            mstore(0x40, add(result, 0xa0)) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns the initialization code hash of the minimal ERC1967 beacon proxy.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }\n\n    /// @dev Returns the address of the deterministic ERC1967 beacon proxy,\n    /// with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      OTHER OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the address when a contract with initialization code hash,\n    /// `hash`, is deployed with `salt`, by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }\n\n    /// @dev Requires that `salt` starts with either the zero address or `by`.\n    function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"
    },
    "contracts/RaribleCreateX.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.20;\n\n/**\n * @title CreateX Factory Smart Contract\n * @author RARIBLE team\n * @notice Factory smart contract to make easier and safer usage of the\n * `CREATE` (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f0?fork=shanghai) and `CREATE2`\n * (https://web.archive.org/web/20230921103540/https://www.evm.codes/#f5?fork=shanghai) EVM opcodes as well as of\n * `CREATE3`-based (https://web.archive.org/web/20230921103920/https://github.com/ethereum/EIPs/pull/3171) contract creations.\n * @dev To simplify testing of non-public variables and functions, we use the `internal`\n * function visibility specifier `internal` for all variables and functions, even though\n * they could technically be `private` since we do not expect anyone to inherit from\n * the `CreateX` contract.\n * @custom:based-on Implementation by pcaversaccio (https://web.archive.org/web/20230921103111/https://pcaversaccio.com/)\n * and Matt Solomon (https://web.archive.org/web/20230921103335/https://mattsolomon.dev/), modified by RARIBLE team\n * for specific use cases.\n */\ncontract RaribleCreateX {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         IMMUTABLES                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Caches the contract address at construction, to be used for the custom errors.\n     */\n    address internal immutable _SELF = address(this);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CREATE2 MAPPING                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    mapping(address => bool) private _create2Deployed;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      CREATE2 MODIFIER                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\n     * those of the calling account. This provides protection against the salt\n     * being stolen by frontrunners or other attackers. The protection can also be\n     * bypassed if desired by setting each of the first 20 bytes to zero.\n     * @param salt bytes32 The salt value to check against the calling address.\n     * */\n    modifier containsCaller(bytes32 salt) {\n        // prevent contract submissions from being stolen from tx.pool by requiring\n        // that the first 20 bytes of the submitted salt match msg.sender.\n        require(\n        (address(bytes20(salt)) == msg.sender) ||\n        (bytes20(salt) == bytes20(0)),\n        \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n        );\n        _;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                            TYPES                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Struct for the `payable` amounts in a deploy-and-initialise call.\n     */\n    struct Values {\n        uint256 constructorAmount;\n        uint256 initCallAmount;\n    }\n\n    /**\n     * @dev Enum for the selection of a permissioned deploy protection.\n     */\n    enum SenderBytes {\n        MsgSender,\n        ZeroAddress,\n        Random\n    }\n\n    /**\n     * @dev Enum for the selection of a cross-chain redeploy protection.\n     */\n    enum RedeployProtectionFlag {\n        True,\n        False,\n        Unspecified\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Event that is emitted when a contract is successfully created.\n     * @param newContract The address of the new contract.\n     * @param salt The 32-byte random value used to create the contract address.\n     */\n    event ContractCreation(address indexed newContract, bytes32 indexed salt);\n\n    /**\n     * @dev Event that is emitted when a contract is successfully created.\n     * @param newContract The address of the new contract.\n     */\n    event ContractCreation(address indexed newContract);\n\n    /**\n     * @dev Event that is emitted when a `CREATE3` proxy contract is successfully created.\n     * @param newContract The address of the new proxy contract.\n     * @param salt The 32-byte random value used to create the proxy address.\n     */\n    event Create3ProxyContractCreation(address indexed newContract, bytes32 indexed salt);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Error that occurs when the contract creation failed.\n     * @param emitter The contract that emits the error.\n     */\n    error FailedContractCreation(address emitter);\n\n    /**\n     * @dev Error that occurs when the contract initialisation call failed.\n     * @param emitter The contract that emits the error.\n     * @param revertData The data returned by the failed initialisation call.\n     */\n    error FailedContractInitialisation(address emitter, bytes revertData);\n\n    /**\n     * @dev Error that occurs when the salt value is invalid.\n     * @param emitter The contract that emits the error.\n     */\n    error InvalidSalt(address emitter);\n\n    /**\n     * @dev Error that occurs when the nonce value is invalid.\n     * @param emitter The contract that emits the error.\n     */\n    error InvalidNonceValue(address emitter);\n\n    /**\n     * @dev Error that occurs when transferring ether has failed.\n     * @param emitter The contract that emits the error.\n     * @param revertData The data returned by the failed ether transfer.\n     */\n    error FailedEtherTransfer(address emitter, bytes revertData);\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE` opcode and using the creation\n     * bytecode `initCode` and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero,\n     * `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate(bytes memory initCode) public payable returns (address newContract) {\n        assembly (\"memory-safe\") {\n            newContract := create(callvalue(), add(initCode, 0x20), mload(initCode))\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. In order to\n     * save deployment costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount`\n     * is non-zero, `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        assembly (\"memory-safe\") {\n            newContract := create(mload(values), add(initCode, 0x20), mload(initCode))\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, and `msg.value` as inputs. In order to save deployment costs, we do not\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateAndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        newContract = deployCreateAndInit({initCode: initCode, data: data, values: values, refundAddress: msg.sender});\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE` opcode, and initialises\n     * the implementation contract using the implementation address `implementation`, the initialisation\n     * code `data`, and `msg.value` as inputs. Note that if `msg.value` is non-zero, the initialiser\n     * function called via `data` must be `payable`.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreateClone(address implementation, bytes memory data) public payable returns (address proxy) {\n        bytes20 implementationInBytes = bytes20(implementation);\n        assembly (\"memory-safe\") {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                hex\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            mstore(add(clone, 0x14), implementationInBytes)\n            mstore(\n                add(clone, 0x28),\n                hex\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            proxy := create(0, clone, 0x37)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit ContractCreation({newContract: proxy});\n\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\n        _requireSuccessfulContractInitialisation({\n            success: success,\n            returnData: returnData,\n            implementation: implementation\n        });\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP) encoding\n     * scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\n     *\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\n     * first contract address created by another contract is calculated with a non-zero nonce.\n     * @param deployer The 20-byte deployer address.\n     * @param nonce The next 32-byte nonce of the deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreateAddress(address deployer, uint256 nonce) public view returns (address computedAddress) {\n        bytes memory data;\n        bytes1 len = bytes1(0x94);\n\n        // The theoretical allowed limit, based on EIP-2681, for an account nonce is 2**64-2:\n        // https://web.archive.org/web/20230921113252/https://eips.ethereum.org/EIPS/eip-2681.\n        if (nonce > type(uint64).max - 1) {\n            revert InvalidNonceValue({emitter: _SELF});\n        }\n\n        // The integer zero is treated as an empty byte string and therefore has only one length prefix,\n        // 0x80, which is calculated via 0x80 + 0.\n        if (nonce == 0x00) {\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, bytes1(0x80));\n        }\n        // A one-byte integer in the [0x00, 0x7f] range uses its own value as a length prefix, there is no\n        // additional \"0x80 + length\" prefix that precedes it.\n        else if (nonce <= 0x7f) {\n            data = abi.encodePacked(bytes1(0xd6), len, deployer, uint8(nonce));\n        }\n        // In the case of `nonce > 0x7f` and `nonce <= type(uint8).max`, we have the following encoding scheme\n        // (the same calculation can be carried over for higher nonce bytes):\n        // 0xda = 0xc0 (short RLP prefix) + 0x1a (= the bytes length of: 0x94 + address + 0x84 + nonce, in hex),\n        // 0x94 = 0x80 + 0x14 (= the bytes length of an address, 20 bytes, in hex),\n        // 0x84 = 0x80 + 0x04 (= the bytes length of the nonce, 4 bytes, in hex).\n        else if (nonce <= type(uint8).max) {\n            data = abi.encodePacked(bytes1(0xd7), len, deployer, bytes1(0x81), uint8(nonce));\n        } else if (nonce <= type(uint16).max) {\n            data = abi.encodePacked(bytes1(0xd8), len, deployer, bytes1(0x82), uint16(nonce));\n        } else if (nonce <= type(uint24).max) {\n            data = abi.encodePacked(bytes1(0xd9), len, deployer, bytes1(0x83), uint24(nonce));\n        } else if (nonce <= type(uint32).max) {\n            data = abi.encodePacked(bytes1(0xda), len, deployer, bytes1(0x84), uint32(nonce));\n        } else if (nonce <= type(uint40).max) {\n            data = abi.encodePacked(bytes1(0xdb), len, deployer, bytes1(0x85), uint40(nonce));\n        } else if (nonce <= type(uint48).max) {\n            data = abi.encodePacked(bytes1(0xdc), len, deployer, bytes1(0x86), uint48(nonce));\n        } else if (nonce <= type(uint56).max) {\n            data = abi.encodePacked(bytes1(0xdd), len, deployer, bytes1(0x87), uint56(nonce));\n        } else {\n            data = abi.encodePacked(bytes1(0xde), len, deployer, bytes1(0x88), uint64(nonce));\n        }\n\n        computedAddress = address(uint160(uint256(keccak256(data))));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract\n     * using the `CREATE` opcode. For the specification of the Recursive Length Prefix (RLP)\n     * encoding scheme, please refer to p. 19 of the Ethereum Yellow Paper (https://web.archive.org/web/20230921110603/https://ethereum.github.io/yellowpaper/paper.pdf)\n     * and the Ethereum Wiki (https://web.archive.org/web/20230921112807/https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/).\n     * For further insights also, see the following issue: https://web.archive.org/web/20230921112943/https://github.com/transmissions11/solmate/issues/207.\n     *\n     * Based on the EIP-161 (https://web.archive.org/web/20230921113207/https://raw.githubusercontent.com/ethereum/EIPs/master/EIPS/eip-161.md) specification,\n     * all contract accounts on the Ethereum mainnet are initiated with `nonce = 1`. Thus, the\n     * first contract address created by another contract is calculated with a non-zero nonce.\n     * @param nonce The next 32-byte nonce of this contract.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreateAddress(uint256 nonce) public view returns (address computedAddress) {\n        computedAddress = computeCreateAddress({deployer: _SELF, nonce: nonce});\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE2                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the salt value `salt`,\n     * the creation bytecode `initCode`, and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `msg.value` is non-zero, `initCode`\n     * must have a `payable` constructor.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate2(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        assembly (\"memory-safe\") {\n            newContract := create2(callvalue(), add(initCode, 0x20), mload(initCode), guardedSalt)\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\n        _create2Deployed[newContract] = true;\n\n\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\n    }\n\n    /**\n     * @dev Deploys a new contract via calling the `CREATE2` opcode and using the creation bytecode\n     * `initCode` and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\n     * diverse selection of block and transaction properties. This approach does not guarantee true\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate2(bytes memory initCode) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2`.\n        newContract = deployCreate2({salt: _generateSalt(), initCode: initCode});\n    }\n\n    /**\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\n     * along with the initialization code for the contract. Note that the first 20\n     * bytes of the salt must match those of the calling address, which prevents\n     * contract creation events from being submitted by unintended parties.\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\n     * @param initCode bytes The initialization code that will be passed\n     * into the CREATE2 call.\n     * @return newContract Address of the contract that will be created, or the null address\n     * if a contract already exists at that address.\n     */\n    function safeCreate2(bytes32 salt, bytes memory initCode) public payable containsCaller(salt) returns (address newContract) {\n        newContract = deployCreate2({salt: salt, initCode: initCode});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * salt value `salt`, the creation bytecode `initCode`, the initialisation code `data`, the struct\n     * for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs.\n     * In order to save deployment costs, we do not sanity check the `initCode` length. Note that if\n     * `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        assembly (\"memory-safe\") {\n            newContract := create2(mload(values), add(initCode, 0x20), mload(initCode), guardedSalt)\n        }\n        _requireSuccessfulContractCreation({newContract: newContract});\n\n        if (_create2Deployed[newContract]) revert FailedContractCreation({emitter: _SELF});\n        _create2Deployed[newContract] = true;\n\n        emit ContractCreation({newContract: newContract, salt: guardedSalt});\n\n        (bool success, bytes memory returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * salt value `salt`, creation bytecode `initCode`, the initialisation code `data`, the struct for\n     * the `payable` amounts `values`, and `msg.value` as inputs. In order to save deployment costs,\n     * we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor, and any excess ether is returned to `msg.sender`.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: salt,\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable`\n     * amounts `values`, the refund address `refundAddress`, and `msg.value` as inputs. The salt value\n     * is calculated pseudo-randomly using a diverse selection of block and transaction properties.\n     * This approach does not guarantee true randomness! In order to save deployment costs, we do not\n     * sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode`\n     * must have a `payable` constructor.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: refundAddress\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via calling the `CREATE2` opcode and using the\n     * creation bytecode `initCode`, the initialisation code `data`, the struct for the `payable` amounts\n     * `values`, and `msg.value` as inputs. The salt value is calculated pseudo-randomly using a\n     * diverse selection of block and transaction properties. This approach does not guarantee true\n     * randomness! In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2AndInit`.\n        newContract = deployCreate2AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\n     * value `salt`, and initialises the implementation contract using the implementation address\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. Note that if\n     * `msg.value` is non-zero, the initialiser function called via `data` must be `payable`.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2Clone(\n        bytes32 salt,\n        address implementation,\n        bytes memory data\n    ) public payable returns (address proxy) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes20 implementationInBytes = bytes20(implementation);\n        assembly (\"memory-safe\") {\n            let clone := mload(0x40)\n            mstore(\n                clone,\n                hex\"3d_60_2d_80_60_0a_3d_39_81_f3_36_3d_3d_37_3d_3d_3d_36_3d_73_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            mstore(add(clone, 0x14), implementationInBytes)\n            mstore(\n                add(clone, 0x28),\n                hex\"5a_f4_3d_82_80_3e_90_3d_91_60_2b_57_fd_5b_f3_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00\"\n            )\n            proxy := create2(0, clone, 0x37, guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit ContractCreation({newContract: proxy, salt: guardedSalt});\n\n        (bool success, bytes memory returnData) = proxy.call{value: msg.value}(data);\n        _requireSuccessfulContractInitialisation({\n            success: success,\n            returnData: returnData,\n            implementation: implementation\n        });\n    }\n\n    /**\n     * @dev Deploys a new EIP-1167 minimal proxy contract using the `CREATE2` opcode and the salt\n     * value `salt`, and initialises the implementation contract using the implementation address\n     * `implementation`, the initialisation code `data`, and `msg.value` as inputs. The salt value is\n     * calculated pseudo-randomly using a diverse selection of block and transaction properties. This\n     * approach does not guarantee true randomness! Note that if `msg.value` is non-zero, the initialiser\n     * function called via `data` must be `payable`.\n     * @param implementation The 20-byte implementation contract address.\n     * @param data The initialisation code that is passed to the deployed proxy contract.\n     * @return proxy The 20-byte address where the clone was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate2Clone(address implementation, bytes memory data) public payable returns (address proxy) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate2Clone`.\n        proxy = deployCreate2Clone({salt: _generateSalt(), implementation: implementation, data: data});\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) public view returns (address computedAddress) {\n        computedAddress = computeCreate2Address({salt: salt, initCodeHash: initCodeHash, deployer: _SELF});\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address. This implementation is based on OpenZeppelin:\n     * https://web.archive.org/web/20230921113703/https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-contracts/181d518609a9f006fcb97af63e6952e603cf100e/contracts/utils/Create2.sol.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @param deployer The 20-byte deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate2Address(\n        bytes32 salt,\n        bytes32 initCodeHash,\n        address deployer\n    ) public pure returns (address computedAddress) {\n        assembly (\"memory-safe\") {\n            // |                      | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |\n            // |----------------------|---------------------------------------------------------------------------|\n            // | initCodeHash         |                                                        CCCCCCCCCCCCC...CC |\n            // | salt                 |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer             | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF                 |            FF                                                             |\n            // |----------------------|---------------------------------------------------------------------------|\n            // | memory               | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak256(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x40), initCodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer)\n            let start := add(ptr, 0x0b)\n            mstore8(start, 0xff)\n            computedAddress := keccak256(start, 85)\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCodeHash The 32-byte bytecode digest of the contract creation bytecode.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function findCreate2AddressViaHash(bytes32 salt, bytes32 initCodeHash) public view returns (address computedAddress) {\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: initCodeHash, deployer: _SELF});\n        // return null address to signify failure if contract has been deployed.\n        if (_create2Deployed[computedAddress]) return address(0);\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE2` opcode. Any change in the `initCodeHash` or `salt` values will result in a new\n     * destination address.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @param initCode The 32-byte bytecode digest of the contract creation bytecode.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function findCreate2Address(bytes32 salt, bytes memory initCode) public view returns (address computedAddress) {\n        computedAddress = computeCreate2Address({salt: _guard({salt: salt}), initCodeHash: keccak256(abi.encodePacked(initCode)), deployer: _SELF});\n        // return null address to signify failure if contract has been deployed.\n        if (_create2Deployed[computedAddress]) return address(0);\n    }\n\n    /**\n     * @dev Determine if a contract has already been deployed by the factory to a\n     * given address.\n     * @param deploymentAddress address The contract address to check.\n     * @return True if the contract has been deployed, false otherwise.\n     */\n    function hasBeenDeployed(address deploymentAddress) external view returns (bool) {\n        // determine if a contract has been deployed to the provided address.\n        return _create2Deployed[deploymentAddress];\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           CREATE3                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\n     * as inputs. In order to save deployment costs, we do not sanity check the `initCode` length.\n     * Note that if `msg.value` is non-zero, `initCode` must have a `payable` constructor. This\n     * implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security We strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3(bytes32 salt, bytes memory initCode) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes memory proxyChildBytecode = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n        address proxy;\n        assembly (\"memory-safe\") {\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\n\n        newContract = computeCreate3Address({salt: guardedSalt});\n        (bool success, ) = proxy.call{value: msg.value}(initCode);\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n    }\n\n    /**\n     * @dev Deploys a new contract via employing the `CREATE3` pattern (i.e. without an initcode\n     * factor) and using the salt value `salt`, the creation bytecode `initCode`, and `msg.value`\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block\n     * and transaction properties. This approach does not guarantee true randomness! In order to save\n     * deployment costs, we do not sanity check the `initCode` length. Note that if `msg.value` is\n     * non-zero, `initCode` must have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @return newContract The 20-byte address where the contract was deployed.\n     */\n    function deployCreate3(bytes memory initCode) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3`.\n        newContract = deployCreate3({salt: _generateSalt(), initCode: initCode});\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\n     * initialisation code `data`, the struct for the `payable` amounts `values`, the refund address\n     * `refundAddress`, and `msg.value` as inputs. In order to save deployment costs, we do not sanity\n     * check the `initCode` length. Note that if `values.constructorAmount` is non-zero, `initCode` must\n     * have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        bytes32 guardedSalt = _guard({salt: salt});\n        bytes memory proxyChildBytecode = hex\"67_36_3d_3d_37_36_3d_34_f0_3d_52_60_08_60_18_f3\";\n        address proxy;\n        assembly (\"memory-safe\") {\n            proxy := create2(0, add(proxyChildBytecode, 32), mload(proxyChildBytecode), guardedSalt)\n        }\n        if (proxy == address(0)) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n        emit Create3ProxyContractCreation({newContract: proxy, salt: guardedSalt});\n\n        newContract = computeCreate3Address({salt: guardedSalt});\n        (bool success, ) = proxy.call{value: values.constructorAmount}(initCode);\n        _requireSuccessfulContractCreation({success: success, newContract: newContract});\n        emit ContractCreation({newContract: newContract});\n\n        bytes memory returnData;\n        (success, returnData) = newContract.call{value: values.initCallAmount}(data);\n        if (!success) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n\n        if (_SELF.balance != 0) {\n            // Any wei amount previously forced into this contract (e.g. by using the `SELFDESTRUCT`\n            // opcode) will be part of the refund transaction.\n            (success, returnData) = refundAddress.call{value: _SELF.balance}(\"\");\n            if (!success) {\n                revert FailedEtherTransfer({emitter: _SELF, revertData: returnData});\n            }\n        }\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the salt value `salt`, the creation bytecode `initCode`, the\n     * initialisation code `data`, the struct for the `payable` amounts `values`, and `msg.value` as\n     * inputs. In order to save deployment costs, we do not sanity check the `initCode` length. Note\n     * that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     * Furthermore, we strongly recommend implementing a permissioned deploy protection by setting\n     * the first 20 bytes equal to `msg.sender` in the `salt` to prevent maliciously intended frontrun\n     * proxy deployments on other chains.\n     */\n    function deployCreate3AndInit(\n        bytes32 salt,\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: salt,\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\n     * the struct for the `payable` amounts `values`, the refund address `refundAddress`, and `msg.value`\n     * as inputs. The salt value is calculated pseudo-randomly using a diverse selection of block and\n     * transaction properties. This approach does not guarantee true randomness! In order to save deployment\n     * costs, we do not sanity check the `initCode` length. Note that if `values.constructorAmount` is non-zero,\n     * `initCode` must have a `payable` constructor. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @param refundAddress The 20-byte address where any excess ether is returned to.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values,\n        address refundAddress\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: refundAddress\n        });\n    }\n\n    /**\n     * @dev Deploys and initialises a new contract via employing the `CREATE3` pattern (i.e. without\n     * an initcode factor) and using the creation bytecode `initCode`, the initialisation code `data`,\n     * the struct for the `payable` amounts `values`, `msg.value` as inputs. The salt value is calculated\n     * pseudo-randomly using a diverse selection of block and transaction properties. This approach does\n     * not guarantee true randomness! In order to save deployment costs, we do not sanity check the `initCode`\n     * length. Note that if `values.constructorAmount` is non-zero, `initCode` must have a `payable` constructor,\n     * and any excess ether is returned to `msg.sender`. This implementation is based on Solmate:\n     * https://web.archive.org/web/20230921113832/https://raw.githubusercontent.com/transmissions11/solmate/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/CREATE3.sol.\n     * @param initCode The creation bytecode.\n     * @param data The initialisation code that is passed to the deployed contract.\n     * @param values The specific `payable` amounts for the deployment and initialisation call.\n     * @return newContract The 20-byte address where the contract was deployed.\n     * @custom:security This function allows for reentrancy, however we refrain from adding\n     * a mutex lock to keep it as use-case agnostic as possible. Please ensure at the protocol\n     * level that potentially malicious reentrant calls do not affect your smart contract system.\n     */\n    function deployCreate3AndInit(\n        bytes memory initCode,\n        bytes memory data,\n        Values memory values\n    ) public payable returns (address newContract) {\n        // Note that the safeguarding function `_guard` is called as part of the overloaded function\n        // `deployCreate3AndInit`.\n        newContract = deployCreate3AndInit({\n            salt: _generateSalt(),\n            initCode: initCode,\n            data: data,\n            values: values,\n            refundAddress: msg.sender\n        });\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via `deployer` using\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\n     * result in a new destination address. This implementation is based on Solady:\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @param deployer The 20-byte deployer address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate3Address(bytes32 salt, address deployer) public pure returns (address computedAddress) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(0x00, deployer)\n            mstore8(0x0b, 0xff)\n            mstore(0x20, salt)\n            mstore(\n                0x40,\n                hex\"21_c3_5d_be_1b_34_4a_24_88_cf_33_21_d6_ce_54_2f_8e_9f_30_55_44_ff_09_e4_99_3a_62_31_9a_49_7c_1f\"\n            )\n            mstore(0x14, keccak256(0x0b, 0x55))\n            mstore(0x40, ptr)\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01)\n            computedAddress := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via this contract using\n     * the `CREATE3` pattern (i.e. without an initcode factor). Any change in the `salt` value will\n     * result in a new destination address. This implementation is based on Solady:\n     * https://web.archive.org/web/20230921114120/https://raw.githubusercontent.com/Vectorized/solady/1c1ac4ad9c8558001e92d8d1a7722ef67bec75df/src/utils/CREATE3.sol.\n     * @param salt The 32-byte random value used to create the proxy contract address.\n     * @return computedAddress The 20-byte address where a contract will be stored.\n     */\n    function computeCreate3Address(bytes32 salt) public view returns (address computedAddress) {\n        computedAddress = computeCreate3Address({salt: salt, deployer: _SELF});\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      HELPER FUNCTIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /**\n     * @dev Implements different safeguarding mechanisms depending on the encoded values in the salt\n     * (`||` stands for byte-wise concatenation):\n     *   => salt (32 bytes) = 0xbebebebebebebebebebebebebebebebebebebebe||ff||1212121212121212121212\n     *   - The first 20 bytes (i.e. `bebebebebebebebebebebebebebebebebebebebe`) may be used to\n     *     implement a permissioned deploy protection by setting them equal to `msg.sender`,\n     *   - The 21st byte (i.e. `ff`) may be used to implement a cross-chain redeploy protection by\n     *     setting it equal to `0x01`,\n     *   - The last random 11 bytes (i.e. `1212121212121212121212`) allow for 2**88 bits of entropy\n     *     for mining a salt.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @return guardedSalt The guarded 32-byte random value used to create the contract address.\n     */\n    function _guard(bytes32 salt) internal view returns (bytes32 guardedSalt) {\n        (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) = _parseSalt({salt: salt});\n\n        if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.True) {\n            // Configures a permissioned deploy protection as well as a cross-chain redeploy protection.\n            guardedSalt = keccak256(abi.encode(msg.sender, block.chainid, salt));\n        } else if (senderBytes == SenderBytes.MsgSender && redeployProtectionFlag == RedeployProtectionFlag.False) {\n            // Configures solely a permissioned deploy protection.\n            guardedSalt = _efficientHash({a: bytes32(uint256(uint160(msg.sender))), b: salt});\n        } else if (senderBytes == SenderBytes.MsgSender) {\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\n            revert InvalidSalt({emitter: _SELF});\n        } else if (senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.True) {\n            // Configures solely a cross-chain redeploy protection. In order to prevent a pseudo-randomly\n            // generated cross-chain redeploy protection, we enforce the zero address check for the first 20 bytes.\n            guardedSalt = _efficientHash({a: bytes32(block.chainid), b: salt});\n        } else if (\n            senderBytes == SenderBytes.ZeroAddress && redeployProtectionFlag == RedeployProtectionFlag.Unspecified\n        ) {\n            // Reverts if the 21st byte is greater than `0x01` in order to enforce developer explicitness.\n            revert InvalidSalt({emitter: _SELF});\n        } else {\n            // For the non-pseudo-random cases, the salt value `salt` is hashed to prevent the safeguard mechanisms\n            // from being bypassed. Otherwise, the salt value `salt` is not modified.\n            guardedSalt = (salt != _generateSalt()) ? keccak256(abi.encode(salt)) : salt;\n        }\n    }\n\n    /**\n     * @dev Returns the enum for the selection of a permissioned deploy protection as well as a\n     * cross-chain redeploy protection.\n     * @param salt The 32-byte random value used to create the contract address.\n     * @return senderBytes The 8-byte enum for the selection of a permissioned deploy protection.\n     * @return redeployProtectionFlag The 8-byte enum for the selection of a cross-chain redeploy\n     * protection.\n     */\n    function _parseSalt(\n        bytes32 salt\n    ) internal view returns (SenderBytes senderBytes, RedeployProtectionFlag redeployProtectionFlag) {\n        if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.True);\n        } else if (address(bytes20(salt)) == msg.sender && bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.False);\n        } else if (address(bytes20(salt)) == msg.sender) {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.MsgSender, RedeployProtectionFlag.Unspecified);\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.True);\n        } else if (address(bytes20(salt)) == address(0) && bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.False);\n        } else if (address(bytes20(salt)) == address(0)) {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.ZeroAddress, RedeployProtectionFlag.Unspecified);\n        } else if (bytes1(salt[20]) == hex\"01\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.True);\n        } else if (bytes1(salt[20]) == hex\"00\") {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.False);\n        } else {\n            (senderBytes, redeployProtectionFlag) = (SenderBytes.Random, RedeployProtectionFlag.Unspecified);\n        }\n    }\n\n    /**\n     * @dev Returns the `keccak256` hash of `a` and `b` after concatenation.\n     * @param a The first 32-byte value to be concatenated and hashed.\n     * @param b The second 32-byte value to be concatenated and hashed.\n     * @return hash The 32-byte `keccak256` hash of `a` and `b`.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            hash := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Generates pseudo-randomly a salt value using a diverse selection of block and\n     * transaction properties.\n     * @return salt The 32-byte pseudo-random salt value.\n     */\n    function _generateSalt() internal view returns (bytes32 salt) {\n        unchecked {\n            salt = keccak256(\n                abi.encode(\n                    // We don't use `block.number - 256` (the maximum value on the EVM) to accommodate\n                    // any chains that may try to reduce the amount of available historical block hashes.\n                    // We also don't subtract 1 to mitigate any risks arising from consecutive block\n                    // producers on a PoS chain. Therefore, we use `block.number - 32` as a reasonable\n                    // compromise, one we expect should work on most chains, which is 1 epoch on Ethereum\n                    // mainnet. Please note that if you use this function between the genesis block and block\n                    // number 31, the block property `blockhash` will return zero, but the returned salt value\n                    // `salt` will still have a non-zero value due to the hashing characteristic and the other\n                    // remaining properties.\n                    blockhash(block.number - 32),\n                    block.coinbase,\n                    block.number,\n                    block.timestamp,\n                    block.prevrandao,\n                    block.chainid,\n                    msg.sender\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Ensures that `newContract` is a non-zero byte contract.\n     * @param success The Boolean success condition.\n     * @param newContract The 20-byte address where the contract was deployed.\n     */\n    function _requireSuccessfulContractCreation(bool success, address newContract) internal view {\n        // Note that reverting if `newContract == address(0)` isn't strictly necessary here, as if\n        // the deployment fails, `success == false` should already hold. However, since the `CreateX`\n        // contract should be usable and safe on a wide range of chains, this check is cheap enough\n        // that there is no harm in including it (security > gas optimisations). It can potentially\n        // protect against unexpected chain behaviour or a hypothetical compiler bug that doesn't surface\n        // the call success status properly.\n        if (!success || newContract == address(0) || newContract.code.length == 0) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n    }\n\n    /**\n     * @dev Ensures that `newContract` is a non-zero byte contract.\n     * @param newContract The 20-byte address where the contract was deployed.\n     */\n    function _requireSuccessfulContractCreation(address newContract) internal view {\n        if (newContract == address(0) || newContract.code.length == 0) {\n            revert FailedContractCreation({emitter: _SELF});\n        }\n    }\n\n    /**\n     * @dev Ensures that the contract initialisation call to `implementation` has been successful.\n     * @param success The Boolean success condition.\n     * @param returnData The return data from the contract initialisation call.\n     * @param implementation The 20-byte address where the implementation was deployed.\n     */\n    function _requireSuccessfulContractInitialisation(\n        bool success,\n        bytes memory returnData,\n        address implementation\n    ) internal view {\n        if (!success || implementation.code.length == 0) {\n            revert FailedContractInitialisation({emitter: _SELF, revertData: returnData});\n        }\n    }\n}"
    },
    "test/contracts/Simple.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Simple {\n    uint256 public value = 42;\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}