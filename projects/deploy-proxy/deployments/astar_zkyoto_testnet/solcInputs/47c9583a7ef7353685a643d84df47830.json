{
  "language": "Solidity",
  "sources": {
    "contracts/ImmutableCreate2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.10; // optimization enabled, 99999 runs, evm: petersburg\n\n\n/**\n * @title Immutable Create2 Contract Factory\n * @author 0age\n * @notice This contract provides a safeCreate2 function that takes a salt value\n * and a block of initialization code as arguments and passes them into inline\n * assembly. The contract prevents redeploys by maintaining a mapping of all\n * contracts that have already been deployed, and prevents frontrunning or other\n * collisions by requiring that the first 20 bytes of the salt are equal to the\n * address of the caller (this can be bypassed by setting the first 20 bytes to\n * the null address). There is also a view function that computes the address of\n * the contract that will be created when submitting a given salt or nonce along\n * with a given block of initialization code.\n * @dev This contract has not yet been fully tested or audited - proceed with\n * caution and please share any exploits or optimizations you discover.\n */\ncontract ImmutableCreate2Factory {\n  // mapping to track which addresses have already been deployed.\n  mapping(address => bool) private _deployed;\n\n  /**\n   * @dev Create a contract using CREATE2 by submitting a given salt or nonce\n   * along with the initialization code for the contract. Note that the first 20\n   * bytes of the salt must match those of the calling address, which prevents\n   * contract creation events from being submitted by unintended parties.\n   * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\n   * @param initializationCode bytes The initialization code that will be passed\n   * into the CREATE2 call.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract already exists at that address.\n   */\n  function safeCreate2(\n    bytes32 salt,\n    bytes calldata initializationCode\n  ) external payable containsCaller(salt) returns (address deploymentAddress) {\n    // move the initialization code from calldata to memory.\n    bytes memory initCode = initializationCode;\n\n    // determine the target address for contract deployment.\n    address targetDeploymentAddress = address(\n      uint160(                    // downcast to match the address type.\n        uint256(                  // convert to uint to truncate upper digits.\n          keccak256(              // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(     // pack all inputs to the hash together.\n              hex\"ff\",            // start with 0xff to distinguish from RLP.\n              address(this),      // this contract will be the caller.\n              salt,               // pass in the supplied salt value.\n              keccak256(          // pass in the hash of initialization code.\n                abi.encodePacked(\n                  initCode\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n\n    // ensure that a contract hasn't been previously deployed to target address.\n    require(\n      !_deployed[targetDeploymentAddress],\n      \"Invalid contract creation - contract has already been deployed.\"\n    );\n\n    // using inline assembly: load data and length of data, then call CREATE2.\n    assembly {                                // solhint-disable-line\n      let encoded_data := add(0x20, initCode) // load initialization code.\n      let encoded_size := mload(initCode)     // load the init code's length.\n      deploymentAddress := create2(           // call CREATE2 with 4 arguments.\n        callvalue,                            // forward any attached value.\n        encoded_data,                         // pass in initialization code.\n        encoded_size,                         // pass in init code's length.\n        salt                                  // pass in the salt value.\n      )\n    }\n\n    // check address against target to ensure that deployment was successful.\n    require(\n      deploymentAddress == targetDeploymentAddress,\n      \"Failed to deploy contract using provided salt and initialization code.\"\n    );\n\n    // record the deployment of the contract to prevent redeploys.\n    _deployed[deploymentAddress] = true;\n  }\n\n  /**\n   * @dev Compute the address of the contract that will be created when\n   * submitting a given salt or nonce to the contract along with the contract's\n   * initialization code. The CREATE2 address is computed in accordance with\n   * EIP-1014, and adheres to the formula therein of\n   * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\n   * performing the computation. The computed address is then checked for any\n   * existing contract code - if so, the null address will be returned instead.\n   * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\n   * @param initCode bytes The contract initialization code to be used.\n   * that will be passed into the CREATE2 address calculation.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract has already been deployed to that address.\n   */\n  function findCreate2Address(\n    bytes32 salt,\n    bytes calldata initCode\n  ) external view returns (address deploymentAddress) {\n    // determine the address where the contract will be deployed.\n    deploymentAddress = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\n              address(this),        // this contract will be the caller.\n              salt,                 // pass in the supplied salt value.\n              keccak256(            // pass in the hash of initialization code.\n                abi.encodePacked(\n                  initCode\n                )\n              )\n            )\n          )\n        )\n      )\n    );\n\n    // return null address to signify failure if contract has been deployed.\n    if (_deployed[deploymentAddress]) {\n      return address(0);\n    }\n  }\n\n  /**\n   * @dev Compute the address of the contract that will be created when\n   * submitting a given salt or nonce to the contract along with the keccak256\n   * hash of the contract's initialization code. The CREATE2 address is computed\n   * in accordance with EIP-1014, and adheres to the formula therein of\n   * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\n   * performing the computation. The computed address is then checked for any\n   * existing contract code - if so, the null address will be returned instead.\n   * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\n   * @param initCodeHash bytes32 The keccak256 hash of the initialization code\n   * that will be passed into the CREATE2 address calculation.\n   * @return Address of the contract that will be created, or the null address\n   * if a contract has already been deployed to that address.\n   */\n  function findCreate2AddressViaHash(\n    bytes32 salt,\n    bytes32 initCodeHash\n  ) external view returns (address deploymentAddress) {\n    // determine the address where the contract will be deployed.\n    deploymentAddress = address(\n      uint160(                      // downcast to match the address type.\n        uint256(                    // convert to uint to truncate upper digits.\n          keccak256(                // compute the CREATE2 hash using 4 inputs.\n            abi.encodePacked(       // pack all inputs to the hash together.\n              hex\"ff\",              // start with 0xff to distinguish from RLP.\n              address(this),        // this contract will be the caller.\n              salt,                 // pass in the supplied salt value.\n              initCodeHash          // pass in the hash of initialization code.\n            )\n          )\n        )\n      )\n    );\n\n    // return null address to signify failure if contract has been deployed.\n    if (_deployed[deploymentAddress]) {\n      return address(0);\n    }\n  }\n\n  /**\n   * @dev Determine if a contract has already been deployed by the factory to a\n   * given address.\n   * @param deploymentAddress address The contract address to check.\n   * @return True if the contract has been deployed, false otherwise.\n   */\n  function hasBeenDeployed(\n    address deploymentAddress\n  ) external view returns (bool) {\n    // determine if a contract has been deployed to the provided address.\n    return _deployed[deploymentAddress];\n  }\n\n  /**\n   * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\n   * those of the calling account. This provides protection against the salt\n   * being stolen by frontrunners or other attackers. The protection can also be\n   * bypassed if desired by setting each of the first 20 bytes to zero.\n   * @param salt bytes32 The salt value to check against the calling address.\n   */\n  modifier containsCaller(bytes32 salt) {\n    // prevent contract submissions from being stolen from tx.pool by requiring\n    // that the first 20 bytes of the submitted salt match msg.sender.\n    require(\n      (address(bytes20(salt)) == msg.sender) ||\n      (bytes20(salt) == bytes20(0)),\n      \"Invalid salt - first 20 bytes of the salt must match calling address.\"\n    );\n    _;\n  }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 99999
    },
    "evmVersion": "petersburg",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}