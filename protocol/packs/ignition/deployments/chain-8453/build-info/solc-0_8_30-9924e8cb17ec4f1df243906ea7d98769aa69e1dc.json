{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-9924e8cb17ec4f1df243906ea7d98769aa69e1dc",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/NftPool.sol": "project/contracts/NftPool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.4.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/access/AccessControlUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"@openzeppelin/contracts/access/IAccessControl.sol\";\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ERC165Upgradeable} from \"../utils/introspection/ERC165Upgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControl, ERC165Upgradeable {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.AccessControl\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.AccessControl\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/access/OwnableUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/proxy/utils/Initializable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {Initializable} from \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or\n * {IERC721-setApprovalForAll}.\n */\nabstract contract ERC721HolderUpgradeable is Initializable, IERC721Receiver {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/ContextUpgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts-upgradeable@5.4.0/utils/introspection/ERC165Upgradeable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165 {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/access/IAccessControl.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC-721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC-721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC-721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC721/IERC721Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity >=0.5.0;\n\n/**\n * @title ERC-721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC-721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/NftPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {ERC721HolderUpgradeable} from \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n/// @title NftPool\n/// @notice Single pool holding all NFTs, organized by pool levels based on price ranges.\n/// @dev Collections are assigned to a pool level by floor price.\n/// NFTs are tracked per collection; pools maintain aggregate counts (no per-NFT migration on floor change).\ncontract NftPool is Initializable, ERC721HolderUpgradeable, OwnableUpgradeable, AccessControlUpgradeable {\n    // -----------------------\n    // Types\n    // -----------------------\n    /// @dev Pool levels ordered from common to rare\n    enum PoolLevel {\n        Common,\n        Rare,\n        Epic,\n        Legendary,\n        UltraRare\n    }\n    /// @dev Number of defined pool levels (update if enum is extended)\n    uint256 private constant _POOL_LEVEL_COUNT = uint256(PoolLevel.UltraRare) + 1;\n    /// @dev Pool price range configuration + collections + aggregate NFT count\n    struct PoolInfo {\n        uint256 lowPrice; // Minimum floor price (inclusive)\n        uint256 highPrice; // Maximum floor price (exclusive)\n        address[] collections; // Collections currently assigned to this pool\n        uint256 totalNfts; // Total NFTs (across all collections) in this pool\n    }\n    /// @dev Lightweight config struct for pool ranges (no collections/total)\n    struct PoolRange {\n        uint256 lowPrice;\n        uint256 highPrice;\n    }\n    /// @dev Per-collection configuration and pool membership\n    /// @notice \"Allowed\" is derived from poolIndexPlusOne != 0\n    struct CollectionInfo {\n        uint256 floorPrice; // Current floor price in wei\n        PoolLevel poolLevel; // Logical pool level for this collection\n        uint256 poolIndexPlusOne; // 1-based index in PoolInfo.collections, 0 = not assigned / not allowed\n    }\n    // -----------------------\n    // Storage\n    // -----------------------\n    /// @dev Pool level => price range configuration + collections + aggregate count\n    mapping(PoolLevel => PoolInfo) private _poolInfo;\n    /// @dev Collection address => collection info\n    mapping(address => CollectionInfo) private _collectionInfo;\n    /// @dev Per-collection NFTs held by the pool (only tokenIds, collection is the key)\n    mapping(address => uint256[]) private _collectionTokens;\n    /// @dev Index of a tokenId inside _collectionTokens[collection] (1-based, 0 = not tracked)\n    mapping(address => mapping(uint256 => uint256)) private _collectionTokenIndexPlusOne;\n    // -----------------------\n    // Roles\n    // -----------------------\n    bytes32 public constant POOL_MANAGER_ROLE = keccak256(\"POOL_MANAGER_ROLE\");\n    // -----------------------\n    // Events\n    // -----------------------\n    event Deposited(address indexed collection, uint256 indexed tokenId, PoolLevel indexed poolLevel);\n    event Withdrawn(address indexed to, address indexed collection, uint256 indexed tokenId, PoolLevel poolLevel);\n    event PoolInfoUpdated(PoolLevel indexed poolLevel, uint256 lowPrice, uint256 highPrice);\n    event CollectionConfigured(address indexed collection, bool allowed, uint256 floorPrice);\n    event CollectionFloorPriceUpdated(address indexed collection, uint256 oldPrice, uint256 newPrice);\n    event CollectionAllowedUpdated(address indexed collection, bool allowed);\n    event RescuedNft(address indexed to, address indexed collection, uint256 indexed tokenId);\n    // -----------------------\n    // Errors\n    // -----------------------\n    error CollectionNotAllowed();\n    error NotInPool();\n    error ZeroAddress();\n    error ArrayLengthMismatch();\n    error LevelEmpty(PoolLevel level);\n    error FloorPriceNotSet();\n    error InvalidPriceRange();\n    error IndexOutOfBounds();\n    error AlreadyTracked();\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    // -----------------------\n    // Init\n    // -----------------------\n    /// @notice Initialize pool with owner and optional custom pool ranges\n    /// @param initialOwner Owner / admin address\n    /// @param ranges Optional array of pool ranges, length must equal number of pool levels.\n    /// If empty, default ETH ranges are used.\n    function initialize(address initialOwner, PoolRange[] calldata ranges) external initializer {\n        if (initialOwner == address(0)) revert ZeroAddress();\n        __ERC721Holder_init();\n        __Ownable_init(initialOwner);\n        __AccessControl_init();\n        _grantRole(DEFAULT_ADMIN_ROLE, initialOwner);\n        _grantRole(POOL_MANAGER_ROLE, initialOwner);\n        if (ranges.length == 0) {\n            // Default price ranges (in wei), scaled for 10% average profit\n            // Common: 0 - 0.05325 ETH\n            // Rare: 0.05325 - 0.213 ETH\n            // Epic: 0.213 - 1.065 ETH\n            // Legendary: 1.065 - 5.325 ETH\n            // UltraRare: 5.325+ ETH (no practical upper bound)\n            _poolInfo[PoolLevel.Common].lowPrice = 0;\n            _poolInfo[PoolLevel.Common].highPrice = 0.05325 ether;\n            _poolInfo[PoolLevel.Rare].lowPrice = 0.05325 ether;\n            _poolInfo[PoolLevel.Rare].highPrice = 0.213 ether;\n            _poolInfo[PoolLevel.Epic].lowPrice = 0.213 ether;\n            _poolInfo[PoolLevel.Epic].highPrice = 1.065 ether;\n            _poolInfo[PoolLevel.Legendary].lowPrice = 1.065 ether;\n            _poolInfo[PoolLevel.Legendary].highPrice = 5.325 ether;\n            _poolInfo[PoolLevel.UltraRare].lowPrice = 5.325 ether;\n            _poolInfo[PoolLevel.UltraRare].highPrice = type(uint256).max;\n        } else {\n            if (ranges.length != _POOL_LEVEL_COUNT) revert ArrayLengthMismatch();\n            for (uint256 i = 0; i < ranges.length; i++) {\n                PoolRange calldata cfg = ranges[i];\n                if (cfg.lowPrice >= cfg.highPrice) revert InvalidPriceRange();\n                PoolLevel level = PoolLevel(i);\n                PoolInfo storage p = _poolInfo[level];\n                p.lowPrice = cfg.lowPrice;\n                p.highPrice = cfg.highPrice;\n                emit PoolInfoUpdated(level, cfg.lowPrice, cfg.highPrice);\n            }\n        }\n    }\n    // -----------------------\n    // Admin: Pool Configuration\n    // -----------------------\n    /// @notice Set price range for a pool level\n    /// @param level The pool level to configure\n    /// @param lowPrice Minimum floor price (inclusive)\n    /// @param highPrice Maximum floor price (exclusive)\n    function setPoolInfo(PoolLevel level, uint256 lowPrice, uint256 highPrice) external onlyOwner {\n        if (lowPrice >= highPrice) revert InvalidPriceRange();\n        PoolInfo storage info = _poolInfo[level];\n        info.lowPrice = lowPrice;\n        info.highPrice = highPrice;\n        emit PoolInfoUpdated(level, lowPrice, highPrice);\n    }\n    /// @notice Batch set all pool price ranges via array\n    /// @dev ranges.length must equal number of pool levels\n    function setAllPoolInfo(PoolRange[] calldata ranges) external onlyOwner {\n        if (ranges.length != _POOL_LEVEL_COUNT) revert ArrayLengthMismatch();\n        for (uint256 i = 0; i < ranges.length; i++) {\n            PoolRange calldata cfg = ranges[i];\n            if (cfg.lowPrice >= cfg.highPrice) revert InvalidPriceRange();\n            PoolLevel level = PoolLevel(i);\n            PoolInfo storage info = _poolInfo[level];\n            info.lowPrice = cfg.lowPrice;\n            info.highPrice = cfg.highPrice;\n            emit PoolInfoUpdated(level, cfg.lowPrice, cfg.highPrice);\n        }\n    }\n    // -----------------------\n    // Internal: Collection Pool Membership\n    // -----------------------\n    function _addCollectionToPool(address collection, PoolLevel level) internal {\n        PoolInfo storage pool = _poolInfo[level];\n        pool.collections.push(collection);\n        uint256 indexPlusOne = pool.collections.length;\n        CollectionInfo storage info = _collectionInfo[collection];\n        info.poolIndexPlusOne = indexPlusOne;\n        info.poolLevel = level;\n    }\n    function _removeCollectionFromPool(address collection, PoolLevel level) internal {\n        CollectionInfo storage info = _collectionInfo[collection];\n        uint256 indexPlusOne = info.poolIndexPlusOne;\n        if (indexPlusOne == 0) {\n            return; // already not assigned\n        }\n        PoolInfo storage pool = _poolInfo[level];\n        uint256 index = indexPlusOne - 1;\n        uint256 lastIndex = pool.collections.length - 1;\n        if (index != lastIndex) {\n            address lastCollection = pool.collections[lastIndex];\n            pool.collections[index] = lastCollection;\n            CollectionInfo storage lastInfo = _collectionInfo[lastCollection];\n            lastInfo.poolIndexPlusOne = index + 1;\n            // lastInfo.poolLevel stays 'level'\n        }\n        pool.collections.pop();\n        info.poolIndexPlusOne = 0;\n        // info.poolLevel will be updated by caller (_setCollectionConfig)\n    }\n    /// @dev Core function to configure collection, used by all public setters\n    function _setCollectionConfig(address collection, bool allowed, uint256 newFloorPrice) internal {\n        if (allowed && newFloorPrice == 0) revert FloorPriceNotSet();\n        CollectionInfo storage info = _collectionInfo[collection];\n        bool wasAllowed = info.poolIndexPlusOne != 0;\n        uint256 oldPrice = info.floorPrice;\n        PoolLevel oldLevel = info.poolLevel;\n        uint256 tokensCount = _collectionTokens[collection].length;\n        info.floorPrice = newFloorPrice;\n        PoolLevel newLevel = _getPoolLevelForPrice(newFloorPrice);\n        // membership transitions\n        if (wasAllowed) {\n            if (!allowed) {\n                // allowed -> not allowed\n                _removeCollectionFromPool(collection, oldLevel);\n                if (tokensCount > 0) {\n                    _poolInfo[oldLevel].totalNfts -= tokensCount;\n                }\n            } else {\n                // allowed -> allowed\n                if (newLevel != oldLevel) {\n                    _removeCollectionFromPool(collection, oldLevel);\n                    _addCollectionToPool(collection, newLevel);\n                    if (tokensCount > 0) {\n                        _poolInfo[oldLevel].totalNfts -= tokensCount;\n                        _poolInfo[newLevel].totalNfts += tokensCount;\n                    }\n                }\n            }\n        } else {\n            if (allowed) {\n                // not allowed -> allowed\n                _addCollectionToPool(collection, newLevel);\n                if (tokensCount > 0) {\n                    _poolInfo[newLevel].totalNfts += tokensCount;\n                }\n            }\n            // not allowed -> not allowed : no pool membership\n        }\n        // logical level always updated\n        info.poolLevel = newLevel;\n        emit CollectionConfigured(collection, allowed, newFloorPrice);\n        if (oldPrice != newFloorPrice) {\n            emit CollectionFloorPriceUpdated(collection, oldPrice, newFloorPrice);\n        }\n        if (wasAllowed != allowed) {\n            emit CollectionAllowedUpdated(collection, allowed);\n        }\n    }\n    // -----------------------\n    // Admin: Collection Configuration\n    // -----------------------\n    /// @notice Configure a collection (allowed status and floor price)\n    /// @param collection NFT collection address\n    /// @param allowed Whether deposits are accepted (true => collection is included in a pool)\n    /// @param floorPrice Current floor price in wei\n    function configureCollection(\n        address collection,\n        bool allowed,\n        uint256 floorPrice\n    ) external onlyRole(POOL_MANAGER_ROLE) {\n        if (collection == address(0)) revert ZeroAddress();\n        _setCollectionConfig(collection, allowed, floorPrice);\n    }\n    /// @notice Batch configure multiple collections\n    function configureCollections(\n        address[] calldata collections,\n        bool[] calldata allowedList,\n        uint256[] calldata floorPrices\n    ) external onlyRole(POOL_MANAGER_ROLE) {\n        if (collections.length != allowedList.length || collections.length != floorPrices.length) {\n            revert ArrayLengthMismatch();\n        }\n        for (uint256 i = 0; i < collections.length; i++) {\n            if (collections[i] == address(0)) revert ZeroAddress();\n            _setCollectionConfig(collections[i], allowedList[i], floorPrices[i]);\n        }\n    }\n    /// @notice Update floor price for a collection and mark it as allowed\n    /// @dev Pool level and aggregate NFT counts are adjusted without per-NFT migration.\n    /// Calling this will always mark the collection as allowed.\n    function setCollectionFloorPrice(address collection, uint256 newPrice) external onlyRole(POOL_MANAGER_ROLE) {\n        if (collection == address(0)) revert ZeroAddress();\n        _setCollectionConfig(collection, true, newPrice);\n    }\n    /// @notice Batch update floor prices and mark all collections as allowed\n    function setCollectionFloorPrices(\n        address[] calldata collections,\n        uint256[] calldata floorPrices\n    ) external onlyRole(POOL_MANAGER_ROLE) {\n        if (collections.length != floorPrices.length) revert ArrayLengthMismatch();\n        for (uint256 i = 0; i < collections.length; i++) {\n            if (collections[i] == address(0)) revert ZeroAddress();\n            _setCollectionConfig(collections[i], true, floorPrices[i]);\n        }\n    }\n    // -----------------------\n    // Internal: NFT Bookkeeping\n    // -----------------------\n    function _addCollectionToken(address collection, uint256 tokenId, PoolLevel level) internal {\n        // protect from duplicates\n        if (_collectionTokenIndexPlusOne[collection][tokenId] != 0) revert AlreadyTracked();\n        uint256[] storage tokens = _collectionTokens[collection];\n        tokens.push(tokenId);\n        _collectionTokenIndexPlusOne[collection][tokenId] = tokens.length;\n        // Only count NFTs of allowed collections in pool totals\n        if (_collectionInfo[collection].poolIndexPlusOne != 0) {\n            _poolInfo[level].totalNfts += 1;\n        }\n        emit Deposited(collection, tokenId, level);\n    }\n    function _removeCollectionToken(address collection, uint256 tokenId, PoolLevel level) internal {\n        uint256 indexPlusOne = _collectionTokenIndexPlusOne[collection][tokenId];\n        if (indexPlusOne == 0) revert NotInPool();\n        uint256[] storage tokens = _collectionTokens[collection];\n        uint256 index = indexPlusOne - 1;\n        uint256 lastIndex = tokens.length - 1;\n        if (index != lastIndex) {\n            uint256 lastTokenId = tokens[lastIndex];\n            tokens[index] = lastTokenId;\n            _collectionTokenIndexPlusOne[collection][lastTokenId] = index + 1;\n        }\n        tokens.pop();\n        delete _collectionTokenIndexPlusOne[collection][tokenId];\n        // Adjust totalNfts only if collection is currently allowed\n        if (_collectionInfo[collection].poolIndexPlusOne != 0) {\n            _poolInfo[level].totalNfts -= 1;\n        }\n    }\n    // -----------------------\n    // Pool Operations\n    // -----------------------\n    /// @notice Deposit an NFT into the pool\n    /// @dev Uses safeTransferFrom; we also add to internal bookkeeping here\n    /// in case some collections don't properly call onERC721Received.\n    function deposit(address collection, uint256 tokenId) external {\n        CollectionInfo storage info = _collectionInfo[collection];\n        if (info.poolIndexPlusOne == 0) revert CollectionNotAllowed();\n        if (info.floorPrice == 0) revert FloorPriceNotSet();\n        IERC721(collection).safeTransferFrom(msg.sender, address(this), tokenId);\n        // If for some reason onERC721Received was not called or didn't track,\n        // ensure the NFT is accounted here.\n        if (_collectionTokenIndexPlusOne[collection][tokenId] == 0) {\n            _addCollectionToken(collection, tokenId, info.poolLevel);\n        }\n    }\n    /// @notice Transfer an NFT out of the pool\n    function transferNft(address collection, address to, uint256 tokenId) external onlyRole(POOL_MANAGER_ROLE) {\n        CollectionInfo storage info = _collectionInfo[collection];\n        PoolLevel level = info.poolLevel;\n        _removeCollectionToken(collection, tokenId, level);\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n        emit Withdrawn(to, collection, tokenId, level);\n    }\n    /// @notice Rescue an NFT that was sent incorrectly and is not tracked\n    function rescueNft(address collection, address to, uint256 tokenId) external onlyOwner {\n        require(_collectionTokenIndexPlusOne[collection][tokenId] == 0, \"NftPool: NFT is tracked\");\n        require(IERC721(collection).ownerOf(tokenId) == address(this), \"NftPool: not owned\");\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n        emit RescuedNft(to, collection, tokenId);\n    }\n    // -----------------------\n    // ERC721 Receiver\n    // -----------------------\n    function onERC721Received(\n        address /* operator */,\n        address /* from */,\n        uint256 tokenId,\n        bytes memory /* data */\n    ) public virtual override returns (bytes4) {\n        address collection = msg.sender;\n        CollectionInfo storage info = _collectionInfo[collection];\n        // Only track if collection is configured (in some pool) and price > 0\n        if (info.poolIndexPlusOne != 0 && info.floorPrice > 0) {\n            _addCollectionToken(collection, tokenId, info.poolLevel);\n        }\n        return this.onERC721Received.selector;\n    }\n    // -----------------------\n    // Internal: Pool Level Logic\n    // -----------------------\n    /// @dev Determine pool level based on floor price using configured ranges\n    /// @notice Iterates over all levels; if overlapping ranges exist,\n    /// the highest index level that matches wins.\n    function _getPoolLevelForPrice(uint256 price) internal view returns (PoolLevel) {\n        // walk from highest index to lowest\n        for (uint256 i = _POOL_LEVEL_COUNT; i > 0; i--) {\n            PoolLevel level = PoolLevel(i - 1);\n            PoolInfo storage p = _poolInfo[level];\n            if (price >= p.lowPrice && price < p.highPrice) {\n                return level;\n            }\n        }\n        // Fallback if misconfigured: Common\n        return PoolLevel.Common;\n    }\n    // -----------------------\n    // Selection (for PackManager)\n    // -----------------------\n    /// @notice Get count of NFTs at a pool level\n    function getPoolLevelSize(PoolLevel level) external view returns (uint256) {\n        return _poolInfo[level].totalNfts;\n    }\n    /// @notice Get NFT at global index within a pool level (0..size-1)\n    /// @dev Walks collections and per-collection token arrays; O(number of collections in pool).\n    function getPoolLevelNftAt(\n        PoolLevel level,\n        uint256 index\n    ) external view returns (address collection, uint256 tokenId) {\n        if (index >= _poolInfo[level].totalNfts) revert IndexOutOfBounds();\n        return _selectNftAtIndex(level, index);\n    }\n    /// @notice Select and transfer a random NFT from a pool level\n    /// @dev Uses pool.totalNfts and walks collections; no per-NFT migration on floor price changes.\n    function selectAndTransferFromLevel(\n        PoolLevel level,\n        uint256 randomValue,\n        address to\n    ) external onlyRole(POOL_MANAGER_ROLE) returns (address collection, uint256 tokenId) {\n        uint256 total = _poolInfo[level].totalNfts;\n        if (total == 0) revert LevelEmpty(level);\n        (collection, tokenId) = _selectNftAtIndex(level, randomValue % total);\n        _removeCollectionToken(collection, tokenId, level);\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n        emit Withdrawn(to, collection, tokenId, level);\n    }\n    /// @notice Select and lock a random NFT from a pool level without transferring it out.\n    /// @dev Used by PackManager so NFTs stay owned by NftPool and are just removed from accounting.\n    function selectAndLockFromLevel(\n        PoolLevel level,\n        uint256 randomValue\n    ) external onlyRole(POOL_MANAGER_ROLE) returns (address collection, uint256 tokenId) {\n        uint256 total = _poolInfo[level].totalNfts;\n        if (total == 0) revert LevelEmpty(level);\n        (collection, tokenId) = _selectNftAtIndex(level, randomValue % total);\n        // Remove from accounting so it cannot be selected again while locked in a pack\n        _removeCollectionToken(collection, tokenId, level);\n    }\n    /// @dev Find NFT at global index within a pool level\n    function _selectNftAtIndex(\n        PoolLevel level,\n        uint256 globalIndex\n    ) internal view returns (address collection, uint256 tokenId) {\n        address[] storage collections = _poolInfo[level].collections;\n        uint256 remaining = globalIndex;\n        for (uint256 i = 0; i < collections.length; i++) {\n            address coll = collections[i];\n            uint256 count = _collectionTokens[coll].length;\n            if (count > 0 && remaining < count) {\n                return (coll, _collectionTokens[coll][remaining]);\n            }\n            remaining -= count;\n        }\n        revert LevelEmpty(level);\n    }\n    // -----------------------\n    // Locking helpers (for PackManager)\n    // -----------------------\n    /// @notice Re-add a previously locked NFT back into the pool accounting.\n    /// @dev NFT must still be owned by the pool and not currently tracked.\n    function addLockedNft(address collection, uint256 tokenId) external onlyRole(POOL_MANAGER_ROLE) {\n        CollectionInfo storage info = _collectionInfo[collection];\n        if (info.poolIndexPlusOne == 0) revert CollectionNotAllowed();\n        if (IERC721(collection).ownerOf(tokenId) != address(this)) revert NotInPool();\n        if (_collectionTokenIndexPlusOne[collection][tokenId] != 0) revert AlreadyTracked();\n        _addCollectionToken(collection, tokenId, info.poolLevel);\n    }\n    /// @notice Transfer a locked NFT (no longer tracked in accounting) to a recipient.\n    /// @dev Used by PackManager in the NFT-claim path. Does not change pool totals because\n    /// the NFT was removed from accounting when it was locked.\n    function transferLockedNft(address collection, address to, uint256 tokenId) external onlyRole(POOL_MANAGER_ROLE) {\n        if (_collectionTokenIndexPlusOne[collection][tokenId] != 0) revert AlreadyTracked();\n        if (IERC721(collection).ownerOf(tokenId) != address(this)) revert NotInPool();\n        PoolLevel level = _collectionInfo[collection].poolLevel;\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\n        emit Withdrawn(to, collection, tokenId, level);\n    }\n    // -----------------------\n    // Views\n    // -----------------------\n    /// @notice Get total NFTs across all pools\n    function totalPoolSize() external view returns (uint256 total) {\n        for (uint256 i = 0; i < _POOL_LEVEL_COUNT; i++) {\n            total += _poolInfo[PoolLevel(i)].totalNfts;\n        }\n    }\n    /// @notice Get pool price range configuration\n    function getPoolInfo(PoolLevel level) external view returns (uint256 lowPrice, uint256 highPrice) {\n        PoolInfo storage info = _poolInfo[level];\n        return (info.lowPrice, info.highPrice);\n    }\n    /// @notice Get collections currently assigned to a pool level\n    function getPoolCollections(PoolLevel level) external view returns (address[] memory) {\n        return _poolInfo[level].collections;\n    }\n    /// @notice Get collection info\n    function getCollectionInfo(\n        address collection\n    ) external view returns (bool allowed, uint256 floorPrice, PoolLevel poolLevel) {\n        CollectionInfo storage info = _collectionInfo[collection];\n        allowed = info.poolIndexPlusOne != 0;\n        floorPrice = info.floorPrice;\n        poolLevel = info.poolLevel;\n    }\n    /// @notice Get floor price for a collection\n    function getCollectionFloorPrice(address collection) external view returns (uint256) {\n        return _collectionInfo[collection].floorPrice;\n    }\n    /// @notice Check if collection is allowed (i.e. assigned to some pool)\n    function isCollectionAllowed(address collection) external view returns (bool) {\n        return _collectionInfo[collection].poolIndexPlusOne != 0;\n    }\n    /// @notice Get pool level for a collection based on current assignment\n    function getCollectionPoolLevel(address collection) external view returns (PoolLevel) {\n        CollectionInfo storage info = _collectionInfo[collection];\n        return info.poolLevel;\n    }\n    /// @notice Check if NFT is tracked in pool\n    function isNftInPool(address collection, uint256 tokenId) external view returns (bool) {\n        return _collectionTokenIndexPlusOne[collection][tokenId] != 0;\n    }\n    /// @notice Get NFT's current pool level\n    function getNftPoolLevel(address collection, uint256 tokenId) external view returns (PoolLevel) {\n        if (_collectionTokenIndexPlusOne[collection][tokenId] == 0) {\n            revert NotInPool();\n        }\n        return _collectionInfo[collection].poolLevel;\n    }\n    // -----------------------\n    // Overrides\n    // -----------------------\n    function supportsInterface(bytes4 interfaceId) public view override(AccessControlUpgradeable) returns (bool) {\n        return interfaceId == type(IERC721Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n    // -----------------------\n    // Storage Gap\n    // -----------------------\n    uint256[44] private __gap;\n}\n"
      }
    }
  }
}