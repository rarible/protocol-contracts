/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export type FeeStruct = {
  rate: PromiseOrValue<BigNumberish>;
  recipient: PromiseOrValue<string>;
};

export type FeeStructOutput = [number, string] & {
  rate: number;
  recipient: string;
};

export type OrderStruct = {
  trader: PromiseOrValue<string>;
  side: PromiseOrValue<BigNumberish>;
  matchingPolicy: PromiseOrValue<string>;
  collection: PromiseOrValue<string>;
  tokenId: PromiseOrValue<BigNumberish>;
  amount: PromiseOrValue<BigNumberish>;
  paymentToken: PromiseOrValue<string>;
  price: PromiseOrValue<BigNumberish>;
  listingTime: PromiseOrValue<BigNumberish>;
  expirationTime: PromiseOrValue<BigNumberish>;
  fees: FeeStruct[];
  salt: PromiseOrValue<BigNumberish>;
  extraParams: PromiseOrValue<BytesLike>;
};

export type OrderStructOutput = [
  string,
  number,
  string,
  string,
  BigNumber,
  BigNumber,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  FeeStructOutput[],
  BigNumber,
  string
] & {
  trader: string;
  side: number;
  matchingPolicy: string;
  collection: string;
  tokenId: BigNumber;
  amount: BigNumber;
  paymentToken: string;
  price: BigNumber;
  listingTime: BigNumber;
  expirationTime: BigNumber;
  fees: FeeStructOutput[];
  salt: BigNumber;
  extraParams: string;
};

export type InputStruct = {
  order: OrderStruct;
  v: PromiseOrValue<BigNumberish>;
  r: PromiseOrValue<BytesLike>;
  s: PromiseOrValue<BytesLike>;
  extraSignature: PromiseOrValue<BytesLike>;
  signatureVersion: PromiseOrValue<BigNumberish>;
  blockNumber: PromiseOrValue<BigNumberish>;
};

export type InputStructOutput = [
  OrderStructOutput,
  number,
  string,
  string,
  string,
  number,
  BigNumber
] & {
  order: OrderStructOutput;
  v: number;
  r: string;
  s: string;
  extraSignature: string;
  signatureVersion: number;
  blockNumber: BigNumber;
};

export type ExecutionStruct = { sell: InputStruct; buy: InputStruct };

export type ExecutionStructOutput = [InputStructOutput, InputStructOutput] & {
  sell: InputStructOutput;
  buy: InputStructOutput;
};

export interface BlurExchangeInterface extends utils.Interface {
  functions: {
    "FEE_TYPEHASH()": FunctionFragment;
    "INVERSE_BASIS_POINT()": FunctionFragment;
    "NAME()": FunctionFragment;
    "ORACLE_ORDER_TYPEHASH()": FunctionFragment;
    "ORDER_TYPEHASH()": FunctionFragment;
    "POOL()": FunctionFragment;
    "ROOT_TYPEHASH()": FunctionFragment;
    "VERSION()": FunctionFragment;
    "WETH()": FunctionFragment;
    "blockRange()": FunctionFragment;
    "cancelledOrFilled(bytes32)": FunctionFragment;
    "executionDelegate()": FunctionFragment;
    "feeRate()": FunctionFragment;
    "feeRecipient()": FunctionFragment;
    "governor()": FunctionFragment;
    "isInternal()": FunctionFragment;
    "isOpen()": FunctionFragment;
    "nonces(address)": FunctionFragment;
    "oracle()": FunctionFragment;
    "owner()": FunctionFragment;
    "policyManager()": FunctionFragment;
    "proxiableUUID()": FunctionFragment;
    "remainingETH()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "upgradeTo(address)": FunctionFragment;
    "upgradeToAndCall(address,bytes)": FunctionFragment;
    "open()": FunctionFragment;
    "close()": FunctionFragment;
    "initialize(address,address,address,uint256)": FunctionFragment;
    "execute(((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256),((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256))": FunctionFragment;
    "bulkExecute((((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256),((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256))[])": FunctionFragment;
    "_execute(((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256),((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes),uint8,bytes32,bytes32,bytes,uint8,uint256))": FunctionFragment;
    "cancelOrder((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes))": FunctionFragment;
    "cancelOrders((address,uint8,address,address,uint256,uint256,address,uint256,uint256,uint256,(uint16,address)[],uint256,bytes)[])": FunctionFragment;
    "incrementNonce()": FunctionFragment;
    "setExecutionDelegate(address)": FunctionFragment;
    "setPolicyManager(address)": FunctionFragment;
    "setOracle(address)": FunctionFragment;
    "setBlockRange(uint256)": FunctionFragment;
    "setGovernor(address)": FunctionFragment;
    "setFeeRate(uint256)": FunctionFragment;
    "setFeeRecipient(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "FEE_TYPEHASH"
      | "INVERSE_BASIS_POINT"
      | "NAME"
      | "ORACLE_ORDER_TYPEHASH"
      | "ORDER_TYPEHASH"
      | "POOL"
      | "ROOT_TYPEHASH"
      | "VERSION"
      | "WETH"
      | "blockRange"
      | "cancelledOrFilled"
      | "executionDelegate"
      | "feeRate"
      | "feeRecipient"
      | "governor"
      | "isInternal"
      | "isOpen"
      | "nonces"
      | "oracle"
      | "owner"
      | "policyManager"
      | "proxiableUUID"
      | "remainingETH"
      | "renounceOwnership"
      | "transferOwnership"
      | "upgradeTo"
      | "upgradeToAndCall"
      | "open"
      | "close"
      | "initialize"
      | "execute"
      | "bulkExecute"
      | "_execute"
      | "cancelOrder"
      | "cancelOrders"
      | "incrementNonce"
      | "setExecutionDelegate"
      | "setPolicyManager"
      | "setOracle"
      | "setBlockRange"
      | "setGovernor"
      | "setFeeRate"
      | "setFeeRecipient"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "FEE_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "INVERSE_BASIS_POINT",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ORACLE_ORDER_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "ORDER_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "POOL", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "ROOT_TYPEHASH",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "VERSION", values?: undefined): string;
  encodeFunctionData(functionFragment: "WETH", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "blockRange",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancelledOrFilled",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "executionDelegate",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "feeRate", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "feeRecipient",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "governor", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isInternal",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "isOpen", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "nonces",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "oracle", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "policyManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proxiableUUID",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "remainingETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeTo",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeToAndCall",
    values: [PromiseOrValue<string>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "open", values?: undefined): string;
  encodeFunctionData(functionFragment: "close", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [InputStruct, InputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "bulkExecute",
    values: [ExecutionStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "_execute",
    values: [InputStruct, InputStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrder",
    values: [OrderStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelOrders",
    values: [OrderStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementNonce",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setExecutionDelegate",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPolicyManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOracle",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setBlockRange",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setGovernor",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeRate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeRecipient",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "FEE_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "INVERSE_BASIS_POINT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ORACLE_ORDER_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ORDER_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "POOL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "ROOT_TYPEHASH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "VERSION", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "WETH", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "blockRange", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelledOrFilled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executionDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "feeRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "feeRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "governor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isInternal", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isOpen", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonces", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "oracle", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "policyManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proxiableUUID",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "remainingETH",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "upgradeTo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "upgradeToAndCall",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "open", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "close", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "bulkExecute",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "_execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrder",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelOrders",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExecutionDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPolicyManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOracle", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setBlockRange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setGovernor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setFeeRate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setFeeRecipient",
    data: BytesLike
  ): Result;

  events: {
    "AdminChanged(address,address)": EventFragment;
    "BeaconUpgraded(address)": EventFragment;
    "Closed()": EventFragment;
    "Initialized(uint8)": EventFragment;
    "NewBlockRange(uint256)": EventFragment;
    "NewExecutionDelegate(address)": EventFragment;
    "NewFeeRate(uint256)": EventFragment;
    "NewFeeRecipient(address)": EventFragment;
    "NewGovernor(address)": EventFragment;
    "NewOracle(address)": EventFragment;
    "NewPolicyManager(address)": EventFragment;
    "NonceIncremented(address,uint256)": EventFragment;
    "Opened()": EventFragment;
    "OrderCancelled(bytes32)": EventFragment;
    "OrdersMatched(address,address,tuple,bytes32,tuple,bytes32)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Upgraded(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "BeaconUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Closed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewBlockRange"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewExecutionDelegate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewFeeRate"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewFeeRecipient"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewGovernor"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewOracle"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewPolicyManager"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NonceIncremented"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Opened"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrderCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OrdersMatched"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Upgraded"): EventFragment;
}

export interface AdminChangedEventObject {
  previousAdmin: string;
  newAdmin: string;
}
export type AdminChangedEvent = TypedEvent<
  [string, string],
  AdminChangedEventObject
>;

export type AdminChangedEventFilter = TypedEventFilter<AdminChangedEvent>;

export interface BeaconUpgradedEventObject {
  beacon: string;
}
export type BeaconUpgradedEvent = TypedEvent<
  [string],
  BeaconUpgradedEventObject
>;

export type BeaconUpgradedEventFilter = TypedEventFilter<BeaconUpgradedEvent>;

export interface ClosedEventObject {}
export type ClosedEvent = TypedEvent<[], ClosedEventObject>;

export type ClosedEventFilter = TypedEventFilter<ClosedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface NewBlockRangeEventObject {
  blockRange: BigNumber;
}
export type NewBlockRangeEvent = TypedEvent<
  [BigNumber],
  NewBlockRangeEventObject
>;

export type NewBlockRangeEventFilter = TypedEventFilter<NewBlockRangeEvent>;

export interface NewExecutionDelegateEventObject {
  executionDelegate: string;
}
export type NewExecutionDelegateEvent = TypedEvent<
  [string],
  NewExecutionDelegateEventObject
>;

export type NewExecutionDelegateEventFilter =
  TypedEventFilter<NewExecutionDelegateEvent>;

export interface NewFeeRateEventObject {
  feeRate: BigNumber;
}
export type NewFeeRateEvent = TypedEvent<[BigNumber], NewFeeRateEventObject>;

export type NewFeeRateEventFilter = TypedEventFilter<NewFeeRateEvent>;

export interface NewFeeRecipientEventObject {
  feeRecipient: string;
}
export type NewFeeRecipientEvent = TypedEvent<
  [string],
  NewFeeRecipientEventObject
>;

export type NewFeeRecipientEventFilter = TypedEventFilter<NewFeeRecipientEvent>;

export interface NewGovernorEventObject {
  governor: string;
}
export type NewGovernorEvent = TypedEvent<[string], NewGovernorEventObject>;

export type NewGovernorEventFilter = TypedEventFilter<NewGovernorEvent>;

export interface NewOracleEventObject {
  oracle: string;
}
export type NewOracleEvent = TypedEvent<[string], NewOracleEventObject>;

export type NewOracleEventFilter = TypedEventFilter<NewOracleEvent>;

export interface NewPolicyManagerEventObject {
  policyManager: string;
}
export type NewPolicyManagerEvent = TypedEvent<
  [string],
  NewPolicyManagerEventObject
>;

export type NewPolicyManagerEventFilter =
  TypedEventFilter<NewPolicyManagerEvent>;

export interface NonceIncrementedEventObject {
  trader: string;
  newNonce: BigNumber;
}
export type NonceIncrementedEvent = TypedEvent<
  [string, BigNumber],
  NonceIncrementedEventObject
>;

export type NonceIncrementedEventFilter =
  TypedEventFilter<NonceIncrementedEvent>;

export interface OpenedEventObject {}
export type OpenedEvent = TypedEvent<[], OpenedEventObject>;

export type OpenedEventFilter = TypedEventFilter<OpenedEvent>;

export interface OrderCancelledEventObject {
  hash: string;
}
export type OrderCancelledEvent = TypedEvent<
  [string],
  OrderCancelledEventObject
>;

export type OrderCancelledEventFilter = TypedEventFilter<OrderCancelledEvent>;

export interface OrdersMatchedEventObject {
  maker: string;
  taker: string;
  sell: OrderStructOutput;
  sellHash: string;
  buy: OrderStructOutput;
  buyHash: string;
}
export type OrdersMatchedEvent = TypedEvent<
  [string, string, OrderStructOutput, string, OrderStructOutput, string],
  OrdersMatchedEventObject
>;

export type OrdersMatchedEventFilter = TypedEventFilter<OrdersMatchedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface UpgradedEventObject {
  implementation: string;
}
export type UpgradedEvent = TypedEvent<[string], UpgradedEventObject>;

export type UpgradedEventFilter = TypedEventFilter<UpgradedEvent>;

export interface BlurExchange extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: BlurExchangeInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    FEE_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<[BigNumber]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    ORACLE_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    ORDER_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    POOL(overrides?: CallOverrides): Promise<[string]>;

    ROOT_TYPEHASH(overrides?: CallOverrides): Promise<[string]>;

    VERSION(overrides?: CallOverrides): Promise<[string]>;

    WETH(overrides?: CallOverrides): Promise<[string]>;

    blockRange(overrides?: CallOverrides): Promise<[BigNumber]>;

    cancelledOrFilled(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    executionDelegate(overrides?: CallOverrides): Promise<[string]>;

    feeRate(overrides?: CallOverrides): Promise<[BigNumber]>;

    feeRecipient(overrides?: CallOverrides): Promise<[string]>;

    governor(overrides?: CallOverrides): Promise<[string]>;

    isInternal(overrides?: CallOverrides): Promise<[boolean]>;

    isOpen(overrides?: CallOverrides): Promise<[BigNumber]>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    oracle(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<[string]>;

    policyManager(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate that the this implementation remains valid after an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<[string]>;

    remainingETH(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    open(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    close(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _executionDelegate: PromiseOrValue<string>,
      _policyManager: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    bulkExecute(
      executions: ExecutionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    _execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOrder(
      order: OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelOrders(
      orders: OrderStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setExecutionDelegate(
      _executionDelegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPolicyManager(
      _policyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setBlockRange(
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFeeRate(
      _feeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setFeeRecipient(
      _feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  FEE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

  NAME(overrides?: CallOverrides): Promise<string>;

  ORACLE_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  POOL(overrides?: CallOverrides): Promise<string>;

  ROOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

  VERSION(overrides?: CallOverrides): Promise<string>;

  WETH(overrides?: CallOverrides): Promise<string>;

  blockRange(overrides?: CallOverrides): Promise<BigNumber>;

  cancelledOrFilled(
    arg0: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  executionDelegate(overrides?: CallOverrides): Promise<string>;

  feeRate(overrides?: CallOverrides): Promise<BigNumber>;

  feeRecipient(overrides?: CallOverrides): Promise<string>;

  governor(overrides?: CallOverrides): Promise<string>;

  isInternal(overrides?: CallOverrides): Promise<boolean>;

  isOpen(overrides?: CallOverrides): Promise<BigNumber>;

  nonces(
    arg0: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  oracle(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the current owner.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  policyManager(overrides?: CallOverrides): Promise<string>;

  /**
   * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate that the this implementation remains valid after an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
   */
  proxiableUUID(overrides?: CallOverrides): Promise<string>;

  remainingETH(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
   */
  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
   */
  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
   */
  upgradeTo(
    newImplementation: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
   */
  upgradeToAndCall(
    newImplementation: PromiseOrValue<string>,
    data: PromiseOrValue<BytesLike>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  open(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  close(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _executionDelegate: PromiseOrValue<string>,
    _policyManager: PromiseOrValue<string>,
    _oracle: PromiseOrValue<string>,
    _blockRange: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  execute(
    sell: InputStruct,
    buy: InputStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  bulkExecute(
    executions: ExecutionStruct[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  _execute(
    sell: InputStruct,
    buy: InputStruct,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOrder(
    order: OrderStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelOrders(
    orders: OrderStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order
   */
  incrementNonce(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setExecutionDelegate(
    _executionDelegate: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPolicyManager(
    _policyManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOracle(
    _oracle: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setBlockRange(
    _blockRange: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setGovernor(
    _governor: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFeeRate(
    _feeRate: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setFeeRecipient(
    _feeRecipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    FEE_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<string>;

    ORACLE_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    ORDER_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    POOL(overrides?: CallOverrides): Promise<string>;

    ROOT_TYPEHASH(overrides?: CallOverrides): Promise<string>;

    VERSION(overrides?: CallOverrides): Promise<string>;

    WETH(overrides?: CallOverrides): Promise<string>;

    blockRange(overrides?: CallOverrides): Promise<BigNumber>;

    cancelledOrFilled(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    executionDelegate(overrides?: CallOverrides): Promise<string>;

    feeRate(overrides?: CallOverrides): Promise<BigNumber>;

    feeRecipient(overrides?: CallOverrides): Promise<string>;

    governor(overrides?: CallOverrides): Promise<string>;

    isInternal(overrides?: CallOverrides): Promise<boolean>;

    isOpen(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    policyManager(overrides?: CallOverrides): Promise<string>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate that the this implementation remains valid after an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<string>;

    remainingETH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    open(overrides?: CallOverrides): Promise<void>;

    close(overrides?: CallOverrides): Promise<void>;

    initialize(
      _executionDelegate: PromiseOrValue<string>,
      _policyManager: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    bulkExecute(
      executions: ExecutionStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    _execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    cancelOrder(order: OrderStruct, overrides?: CallOverrides): Promise<void>;

    cancelOrders(
      orders: OrderStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order
     */
    incrementNonce(overrides?: CallOverrides): Promise<void>;

    setExecutionDelegate(
      _executionDelegate: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPolicyManager(
      _policyManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setBlockRange(
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeRate(
      _feeRate: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeRecipient(
      _feeRecipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AdminChanged(address,address)"(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;
    AdminChanged(
      previousAdmin?: null,
      newAdmin?: null
    ): AdminChangedEventFilter;

    "BeaconUpgraded(address)"(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;
    BeaconUpgraded(
      beacon?: PromiseOrValue<string> | null
    ): BeaconUpgradedEventFilter;

    "Closed()"(): ClosedEventFilter;
    Closed(): ClosedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "NewBlockRange(uint256)"(blockRange?: null): NewBlockRangeEventFilter;
    NewBlockRange(blockRange?: null): NewBlockRangeEventFilter;

    "NewExecutionDelegate(address)"(
      executionDelegate?: PromiseOrValue<string> | null
    ): NewExecutionDelegateEventFilter;
    NewExecutionDelegate(
      executionDelegate?: PromiseOrValue<string> | null
    ): NewExecutionDelegateEventFilter;

    "NewFeeRate(uint256)"(feeRate?: null): NewFeeRateEventFilter;
    NewFeeRate(feeRate?: null): NewFeeRateEventFilter;

    "NewFeeRecipient(address)"(feeRecipient?: null): NewFeeRecipientEventFilter;
    NewFeeRecipient(feeRecipient?: null): NewFeeRecipientEventFilter;

    "NewGovernor(address)"(governor?: null): NewGovernorEventFilter;
    NewGovernor(governor?: null): NewGovernorEventFilter;

    "NewOracle(address)"(
      oracle?: PromiseOrValue<string> | null
    ): NewOracleEventFilter;
    NewOracle(oracle?: PromiseOrValue<string> | null): NewOracleEventFilter;

    "NewPolicyManager(address)"(
      policyManager?: PromiseOrValue<string> | null
    ): NewPolicyManagerEventFilter;
    NewPolicyManager(
      policyManager?: PromiseOrValue<string> | null
    ): NewPolicyManagerEventFilter;

    "NonceIncremented(address,uint256)"(
      trader?: PromiseOrValue<string> | null,
      newNonce?: null
    ): NonceIncrementedEventFilter;
    NonceIncremented(
      trader?: PromiseOrValue<string> | null,
      newNonce?: null
    ): NonceIncrementedEventFilter;

    "Opened()"(): OpenedEventFilter;
    Opened(): OpenedEventFilter;

    "OrderCancelled(bytes32)"(hash?: null): OrderCancelledEventFilter;
    OrderCancelled(hash?: null): OrderCancelledEventFilter;

    "OrdersMatched(address,address,tuple,bytes32,tuple,bytes32)"(
      maker?: PromiseOrValue<string> | null,
      taker?: PromiseOrValue<string> | null,
      sell?: null,
      sellHash?: null,
      buy?: null,
      buyHash?: null
    ): OrdersMatchedEventFilter;
    OrdersMatched(
      maker?: PromiseOrValue<string> | null,
      taker?: PromiseOrValue<string> | null,
      sell?: null,
      sellHash?: null,
      buy?: null,
      buyHash?: null
    ): OrdersMatchedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;

    "Upgraded(address)"(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
    Upgraded(
      implementation?: PromiseOrValue<string> | null
    ): UpgradedEventFilter;
  };

  estimateGas: {
    FEE_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    INVERSE_BASIS_POINT(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    ORACLE_ORDER_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    ORDER_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    POOL(overrides?: CallOverrides): Promise<BigNumber>;

    ROOT_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>;

    VERSION(overrides?: CallOverrides): Promise<BigNumber>;

    WETH(overrides?: CallOverrides): Promise<BigNumber>;

    blockRange(overrides?: CallOverrides): Promise<BigNumber>;

    cancelledOrFilled(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    executionDelegate(overrides?: CallOverrides): Promise<BigNumber>;

    feeRate(overrides?: CallOverrides): Promise<BigNumber>;

    feeRecipient(overrides?: CallOverrides): Promise<BigNumber>;

    governor(overrides?: CallOverrides): Promise<BigNumber>;

    isInternal(overrides?: CallOverrides): Promise<BigNumber>;

    isOpen(overrides?: CallOverrides): Promise<BigNumber>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    oracle(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    policyManager(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate that the this implementation remains valid after an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<BigNumber>;

    remainingETH(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    open(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    close(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      _executionDelegate: PromiseOrValue<string>,
      _policyManager: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    bulkExecute(
      executions: ExecutionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    _execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOrder(
      order: OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelOrders(
      orders: OrderStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setExecutionDelegate(
      _executionDelegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPolicyManager(
      _policyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setBlockRange(
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFeeRate(
      _feeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setFeeRecipient(
      _feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    FEE_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    INVERSE_BASIS_POINT(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ORACLE_ORDER_TYPEHASH(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    ORDER_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    POOL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    ROOT_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    VERSION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    WETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    blockRange(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    cancelledOrFilled(
      arg0: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    executionDelegate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    feeRate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    feeRecipient(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governor(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isInternal(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isOpen(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonces(
      arg0: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    oracle(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the current owner.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    policyManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the implementation. It is used to validate that the this implementation remains valid after an upgrade. IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
     */
    proxiableUUID(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    remainingETH(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.
     */
    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.
     */
    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeTo(
      newImplementation: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event.
     */
    upgradeToAndCall(
      newImplementation: PromiseOrValue<string>,
      data: PromiseOrValue<BytesLike>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    open(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    close(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _executionDelegate: PromiseOrValue<string>,
      _policyManager: PromiseOrValue<string>,
      _oracle: PromiseOrValue<string>,
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    bulkExecute(
      executions: ExecutionStruct[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    _execute(
      sell: InputStruct,
      buy: InputStruct,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrder(
      order: OrderStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelOrders(
      orders: OrderStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel all current orders for a user, preventing them from being matched. Must be called by the trader of the order
     */
    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setExecutionDelegate(
      _executionDelegate: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPolicyManager(
      _policyManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOracle(
      _oracle: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setBlockRange(
      _blockRange: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setGovernor(
      _governor: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFeeRate(
      _feeRate: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setFeeRecipient(
      _feeRecipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
